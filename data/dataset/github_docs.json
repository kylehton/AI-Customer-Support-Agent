[
  {
    "title": "Basic writing and formatting syntax",
    "content": "## Basic writing and formatting syntax Create sophisticated formatting for your prose and code on GitHub with simple syntax. ## Who can use this feature? Markdown can be used in the GitHub web interface. ## In this article To create a heading, add one to six # symbols before your heading text. The number of # you use will determine the hierarchy level and typeface size of the heading. # A first-level heading ## A second-level heading ### A third-level heading # A first-level heading ## A second-level heading ### A third-level heading When you use two or more headings, GitHub automatically generates a table of contents that you can access by clicking within the file header. Each heading title is listed in the table of contents and you can click a title to navigate to the selected section. ## Styling text You can indicate emphasis with bold, italic, strikethrough, subscript, or superscript text in comment fields and .md files. **This is bold text** _This text is italicized_ ~~This was mistaken text~~ **This text is _extremely_ important** ***All this text is important*** <sub> </sub> This is a <sub>subscript</sub> text <sup> </sup> This is a <sup>superscript</sup> text <ins> </ins> This is an <ins>underlined</ins> text ## Quoting text You can quote text with a >. Text that is not a quote > Text that is a quote Text that is not a quote > Text that is a quote Quoted text is indented with a vertical line on the left and displayed using gray type. When viewing a conversation, you can automatically quote text in a comment by highlighting the text, then typing R. You can quote an entire comment by clicking , then Quote reply. For more information about keyboard shortcuts, see Keyboard shortcuts. ## Quoting code You can call out code or a command within a sentence with single backticks. The text within the backticks will not be formatted. You can also press the Command+E (Mac) or Ctrl+E (Windows/Linux) keyboard shortcut to insert the backticks for a code block within a line of Markdown. Use `git status` to list all new or modified files that haven't yet been committed. Use `git status` to list all new or modified files that haven't yet been committed. To format code or text into its own distinct block, use triple backticks. Some basic Git commands are: ``` git status git add git commit ``` Some basic Git commands are: ``` git status git add git commit ``` For more information, see Creating and highlighting code blocks. If you are frequently editing code snippets and tables, you may benefit from enabling a fixed-width font in all comment fields on GitHub. For more information, see About writing and formatting on GitHub. ## Supported color models In issues, pull requests, and discussions, you can call out colors within a sentence by using backticks. A supported color model within backticks will display a visualization of the color. The background color is `#ffffff` for light mode and `#000000` for dark mode. The background color is `#ffffff` for light mode and `#000000` for dark mode. Here are the currently supported color models. `rgb(R,G,B)` `rgb(9, 105, 218)` `hsl(H,S,L)` `hsl(212, 92%, 45%)` A supported color model cannot have any leading or trailing spaces within the backticks. The visualization of the color is only supported in issues, pull requests, and discussions. You can create an inline link by wrapping link text in brackets [ ], and then wrapping the URL in parentheses ( ). You can also use the keyboard shortcut Command+K to create a link. When you have text selected, you can paste a URL from your clipboard to automatically create a link from the selection. You can also create a Markdown hyperlink by highlighting the text and using the keyboard shortcut Command+V. If you'd like to replace the text with the link, use the keyboard shortcut Command+Shift+V. This site was built using [GitHub Pages](https://pages.github.com/). This site was built using [GitHub Pages](https://pages.github.com/). GitHub automatically creates links when valid URLs are written in a comment. For more information, see Autolinked references and URLs. ## Section links You can link directly to any section that has a heading. To view the automatically generated anchor in a rendered file, hover over the section heading to expose the icon and click the icon to display the anchor in your browser. If you need to determine the anchor for a heading in a file you are editing, you can use the following basic rules: Letters are converted to lower-case. Spaces are replaced by hyphens (-). Any other whitespace or punctuation characters are removed. Leading and trailing whitespace are removed. Markup formatting is removed, leaving only the contents (for example, _italics_ becomes italics). If the automatically generated anchor for a heading is identical to an earlier anchor in the same document, a unique identifier is generated by appending a hyphen and an auto-incrementing integer. For more detailed information on the requirements of URI fragments, see RFC 3986: Uniform Resource Identifier (URI): Generic Syntax, Section 3.5. The code block below demonstrates the basic rules used to generate anchors from headings in rendered content. # Example headings ## Sample Section ## This'll be a _Helpful_ Section About the Greek Letter Θ! A heading containing characters not allowed in fragments, UTF-8 characters, two consecutive spaces between the first and second words, and formatting. ## This heading is not unique in the file TEXT 1 ## This heading is not unique in the file TEXT 2 # Links to the example headings above Link to the sample section: [Link Text](#sample-section). Link to the helpful section: [Link Text](#thisll-be-a-helpful-section-about-the-greek-letter-Θ). Link to the first non-unique section: [Link Text](#this-heading-is-not-unique-in-the-file). Link to the second non-unique section: [Link Text](#this-heading-is-not-unique-in-the-file-1). # Example headings ## Sample Section ## This'll be a _Helpful_ Section About the Greek Letter Θ! A heading containing characters not allowed in fragments, UTF-8 characters, two consecutive spaces between the first and second words, and formatting. ## This heading is not unique in the file TEXT 1 ## This heading is not unique in the file TEXT 2 # Links to the example headings above Link to the sample section: [Link Text](#sample-section). Link to the helpful section: [Link Text](#thisll-be-a-helpful-section-about-the-greek-letter-Θ). Link to the first non-unique section: [Link Text](#this-heading-is-not-unique-in-the-file). Link to the second non-unique section: [Link Text](#this-heading-is-not-unique-in-the-file-1). If you edit a heading, or if you change the order of headings with \"identical\" anchors, you will also need to update any links to those headings as the anchors will change. ## Relative links You can define relative links and image paths in your rendered files to help readers navigate to other files in your repository. A relative link is a link that is relative to the current file. For example, if you have a README file in root of your repository, and you have another file in docs/CONTRIBUTING.md, the relative link to CONTRIBUTING.md in your README might look like this: [Contribution guidelines for this project](docs/CONTRIBUTING.md) [Contribution guidelines for this project](docs/CONTRIBUTING.md) GitHub will automatically transform your relative link or image path based on whatever branch you're currently on, so that the link or path always works. The path of the link will be relative to the current file. Links starting with / will be relative to the repository root. You can use all relative link operands, such as ./ and ../. Your link text should be on a single line. The example below will not work. [Contribution guidelines for this project](docs/CONTRIBUTING.md) [Contribution guidelines for this project](docs/CONTRIBUTING.md) Relative links are easier for users who clone your repository. Absolute links may not work in clones of your repository - we recommend using relative links to refer to other files within your repository. ## Custom anchors You can use standard HTML anchor tags (<a name=\"unique-anchor-name\"></a>) to create navigation anchor points for any location in the document. To avoid ambiguous references, use a unique naming scheme for anchor tags, such as adding a prefix to the name attribute value. <a name=\"unique-anchor-name\"></a> Custom anchors will not be included in the document outline/Table of Contents. You can link to a custom anchor using the value of the name attribute you gave the anchor. The syntax is exactly the same as when you link to an anchor that is automatically generated for a heading. For example: # Section Heading Some body text of this section. <a name=\"my-custom-anchor-point\"></a> Some text I want to provide a direct link to, but which doesn't have its own heading. (… more content…) [A link to that custom anchor](#my-custom-anchor-point) # Section Heading Some body text of this section. <a name=\"my-custom-anchor-point\"></a> Some text I want to provide a direct link to, but which doesn't have its own heading. (… more content…) [A link to that custom anchor](#my-custom-anchor-point) Custom anchors are not considered by the automatic naming and numbering behavior of automatic heading links. ## Line breaks If you're writing in issues, pull requests, or discussions in a repository, GitHub will render a line break automatically: This example Will span two lines This example Will span two lines However, if you are writing in an .md file, the example above would render on one line without a line break. To create a line break in an .md file, you will need to include one of the following: Include two spaces at the end of the first line. This example Will span two lines Include two spaces at the end of the first line. This example Will span two lines Include a backslash at the end of the first line. This example\\ Will span two lines Include a backslash at the end of the first line. This example\\ Will span two lines This example\\ Will span two lines Include an HTML single line break tag at the end of the first line. This example<br/> Will span two lines Include an HTML single line break tag at the end of the first line. This example<br/> Will span two lines This example<br/> Will span two lines If you leave a blank line between two lines, both .md files and Markdown in issues, pull requests, and discussions will render the two lines separated by the blank line: This example Will have a blank line separating both lines This example Will have a blank line separating both lines You can display an image by adding ! and wrapping the alt text in [ ]. Alt text is a short text equivalent of the information in the image. Then, wrap the link for the image in parentheses (). ![Screenshot of a comment on a GitHub issue showing an image, added in the Markdown, of an Octocat smiling and raising a tentacle.](https://myoctocat.com/assets/images/base-octocat.svg) ![Screenshot of a comment on a GitHub issue showing an image, added in the Markdown, of an Octocat smiling and raising a tentacle.](https://myoctocat.com/assets/images/base-octocat.svg) GitHub supports embedding images into your issues, pull requests, discussions, comments and .md files. You can display an image from your repository, add a link to an online image, or upload an image. For more information, see Uploading assets. When you want to display an image that is in your repository, use relative links instead of absolute links. Here are some examples for using relative links to display an image. /assets/images/electrocat.png /../main/assets/images/electrocat.png ../blob/main/assets/images/electrocat.png?raw=true /../../../../github/docs/blob/main/assets/images/electrocat.png ../../../github/docs/blob/main/assets/images/electrocat.png?raw=true The last two relative links in the table above will work for images in a private repository only if the viewer has at least read access to the private repository that contains these images. For more information, see Relative Links. ## The Picture element The <picture> HTML element is supported. You can make an unordered list by preceding one or more lines of text with -, *, or +. - George Washington * John Adams + Thomas Jefferson - George Washington * John Adams + Thomas Jefferson To order your list, precede each line with a number. 1. James Madison 2. James Monroe 3. John Quincy Adams 1. James Madison 2. James Monroe 3. John Quincy Adams ## Nested Lists You can create a nested list by indenting one or more list items below another item. To create a nested list using the web editor on GitHub or a text editor that uses a monospaced font, like Visual Studio Code, you can align your list visually. Type space characters in front of your nested list item until the list marker character (- or *) lies directly below the first character of the text in the item above it. 1. First list item - First nested list item - Second nested list item 1. First list item - First nested list item - Second nested list item In the web-based editor, you can indent or dedent one or more lines of text by first highlighting the desired lines and then using Tab or Shift+Tab respectively. To create a nested list in the comment editor on GitHub, which doesn't use a monospaced font, you can look at the list item immediately above the nested list and count the number of characters that appear before the content of the item. Then type that number of space characters in front of the nested list item. In this example, you could add a nested list item under the list item 100. First list item by indenting the nested list item a minimum of five spaces, since there are five characters (100. ) before First list item. 100. First list item First list item 100. First list item - First nested list item 100. First list item - First nested list item You can create multiple levels of nested lists using the same method. For example, because the first nested list item has seven characters (␣␣␣␣␣-␣) before the nested list content First nested list item, you would need to indent the second nested list item by at least two more characters (nine spaces minimum). First nested list item 100. First list item - First nested list item - Second nested list item 100. First list item - First nested list item - Second nested list item For more examples, see the GitHub Flavored Markdown Spec. To create a task list, preface list items with a hyphen and space followed by [ ]. To mark a task as complete, use [x]. - [x] #739 - [ ] https://github.com/octo-org/octo-repo/issues/740 - [ ] Add delight to the experience when all tasks are complete :tada: - [x] #739 - [ ] https://github.com/octo-org/octo-repo/issues/740 - [ ] Add delight to the experience when all tasks are complete :tada: If a task list item description begins with a parenthesis, you'll need to escape it with \\: - [ ] \\(Optional) Open a followup issue - [ ] \\(Optional) Open a followup issue For more information, see About tasklists. ## Mentioning people and teams You can mention a person or team on GitHub by typing @ plus their username or team name. This will trigger a notification and bring their attention to the conversation. People will also receive a notification if you edit a comment to mention their username or team name. For more information about notifications, see About notifications. A person will only be notified about a mention if the person has read access to the repository and, if the repository is owned by an organization, the person is a member of the organization. @github/support What do you think about these updates? @github/support What do you think about these updates? When you mention a parent team, members of its child teams also receive notifications, simplifying communication with multiple groups of people. For more information, see About teams. Typing an @ symbol will bring up a list of people or teams on a project. The list filters as you type, so once you find the name of the person or team you are looking for, you can use the arrow keys to select it and press either tab or enter to complete the name. For teams, enter the @organization/team-name and all members of that team will get subscribed to the conversation. The autocomplete results are restricted to repository collaborators and any other participants on the thread. ## Referencing issues and pull requests You can bring up a list of suggested issues and pull requests within the repository by typing #. Type the issue or pull request number or title to filter the list, and then press either tab or enter to complete the highlighted result. For more information, see Autolinked references and URLs. ## Referencing external resources If custom autolink references are configured for a repository, then references to external resources, like a JIRA issue or Zendesk ticket, convert into shortened links. To know which autolinks are available in your repository, contact someone with admin permissions to the repository. For more information, see Configuring autolinks to reference external resources. ## Uploading assets You can upload assets like images by dragging and dropping, selecting from a file browser, or pasting. You can upload assets to issues, pull requests, comments, and .md files in your repository. ## Using emojis You can add emoji to your writing by typing :EMOJICODE:, a colon followed by the name of the emoji. :EMOJICODE: @octocat :+1: This PR looks great - it's ready to merge! :shipit: @octocat :+1: This PR looks great - it's ready to merge! :shipit: Typing : will bring up a list of suggested emoji. The list will filter as you type, so once you find the emoji you're looking for, press Tab or Enter to complete the highlighted result. For a full list of available emoji and codes, see the Emoji-Cheat-Sheet. You can create a new paragraph by leaving a blank line between lines of text. You can add footnotes to your content by using this bracket syntax: Here is a simple footnote[^1]. A footnote can also have multiple lines[^2]. [^1]: My reference. [^2]: To add line breaks within a footnote, prefix new lines with 2 spaces. This is a second line. Here is a simple footnote[^1]. A footnote can also have multiple lines[^2]. [^1]: My reference. [^2]: To add line breaks within a footnote, prefix new lines with 2 spaces. This is a second line. The footnote will render like this: The position of a footnote in your Markdown does not influence where the footnote will be rendered. You can write a footnote right after your reference to the footnote, and the footnote will still render at the bottom of the Markdown. Footnotes are not supported in wikis. Alerts are a Markdown extension based on the blockquote syntax that you can use to emphasize critical information. On GitHub, they are displayed with distinctive colors and icons to indicate the significance of the content. Use alerts only when they are crucial for user success and limit them to one or two per article to prevent overloading the reader. Additionally, you should avoid placing alerts consecutively. Alerts cannot be nested within other elements. To add an alert, use a special blockquote line specifying the alert type, followed by the alert information in a standard blockquote. Five types of alerts are available: > [!NOTE] > Useful information that users should know, even when skimming content. > [!TIP] > Helpful advice for doing things better or more easily. > [!IMPORTANT] > Key information users need to know to achieve their goal. > [!WARNING] > Urgent info that needs immediate user attention to avoid problems. > [!CAUTION] > Advises about risks or negative outcomes of certain actions. > [!NOTE] > Useful information that users should know, even when skimming content. > [!TIP] > Helpful advice for doing things better or more easily. > [!IMPORTANT] > Key information users need to know to achieve their goal. > [!WARNING] > Urgent info that needs immediate user attention to avoid problems. > [!CAUTION] > Advises about risks or negative outcomes of certain actions. Here are the rendered alerts: ## Hiding content with comments You can tell GitHub to hide content from the rendered Markdown by placing the content in an HTML comment. <!-- This content will not appear in the rendered Markdown --> <!-- This content will not appear in the rendered Markdown --> ## Ignoring Markdown formatting You can tell GitHub to ignore (or escape) Markdown formatting by using \\ before the Markdown character. Let's rename \\*our-new-project\\* to \\*our-old-project\\*. Let's rename \\*our-new-project\\* to \\*our-old-project\\*. For more information on backslashes, see Daring Fireball's Markdown Syntax. The Markdown formatting will not be ignored in the title of an issue or a pull request. ## Disabling Markdown rendering When viewing a Markdown file, you can click Code at the top of the file to disable Markdown rendering and view the file's source instead. Disabling Markdown rendering enables you to use source view features, such as line linking, which is not possible when viewing rendered Markdown files. ## Further reading GitHub Flavored Markdown Spec About writing and formatting on GitHub Working with advanced formatting Quickstart for writing on GitHub",
    "url": "https://docs.github.com/en/get-started/writing-on-github/getting-started-with-writing-and-formatting-on-github/basic-writing-and-formatting-syntax",
    "section": "Getting Started",
    "word_count": 3469
  },
  {
    "title": "Getting started with GitHub Enterprise Cloud",
    "content": "## Getting started with GitHub Enterprise Cloud Get started with setting up and managing your enterprise account with GitHub Enterprise Cloud. ## In this article This guide will walk you through setting up, configuring and managing your GitHub Enterprise Cloud account as an enterprise owner. GitHub provides two types of Enterprise products: GitHub Enterprise Cloud GitHub Enterprise Server The main difference between the products is that GitHub Enterprise Cloud is hosted by GitHub, while GitHub Enterprise Server is self-hosted. GitHub Enterprise Cloud includes an enterprise account, which allows you to manage multiple organizations. You can choose to let enterprise members create and manage their own personal accounts, or you can use Enterprise Managed Users. For more information about GitHub Enterprise Cloud, see About GitHub Enterprise Cloud. ## Part 1: Setting up your enterprise account To get started with GitHub Enterprise Cloud, decide which type of enterprise to create, create an enterprise account, and add one or more organizations. ## 1. Choosing an enterprise type To control access to your enterprise's resources, you can allow people to use a personal account on GitHub.com and optionally configure additional SAML access restrictions, or you can provision and control the accounts for your enterprise using your identity provider (IdP) with Enterprise Managed Users. Before you begin using GitHub Enterprise Cloud, you must decide which type of enterprise to use. For more information, see Choosing an enterprise type for GitHub Enterprise Cloud. ## 2. About enterprise accounts An enterprise account allows you to centrally manage policy and settings for multiple GitHub organizations, including member access, billing and usage and security. For more information, see About enterprise accounts. ## 3. Creating an enterprise account To create your enterprise account, start a free 30-day trial of GitHub Enterprise Cloud. For more information, see Setting up a trial of GitHub Enterprise Cloud. Try GitHub Enterprise Cloud for free ## 4. Adding organizations to your enterprise account You can add any number of new or existing organizations to manage within your enterprise account. For more information, see Adding organizations to your enterprise. ## 5. Creating a README for the enterprise To help people understand what is happening in your enterprise, you should create a README. For example, you can use a README to help members learn about different organizations in the enterprise, to share links to important resources, or to communicate information about the settings and policies of your enterprise. For more information, see Creating a README for an enterprise. ## 6. Viewing the subscription and usage for your enterprise account You can view your current subscription, license usage, invoices, payment history, and other billing information for your enterprise account at any time. Both enterprise owners and billing managers can access and manage billing settings for enterprise accounts. For more information, see Viewing usage for your GitHub Enterprise plan. ## Part 2: Managing your enterprise members with GitHub Enterprise Cloud If your enterprise uses Enterprise Managed Users, your members are fully managed through your identity provider. Adding members, making changes to their membership, and assigning roles is all managed using your IdP. For more information, see About Enterprise Managed Users. If your enterprise does not use Enterprise Managed Users, follow the steps below. ## 1. Assigning roles in an enterprise By default, everyone in an enterprise is a member of the enterprise. There are also administrative roles, including enterprise owner and billing manager, that have different levels of access to enterprise settings and data. For more information, see Roles in an enterprise. ## 2. Inviting people to manage your enterprise You can invite people to manage your enterprise as enterprise owners or billing managers or remove administrators who no longer need access. For more information, see Inviting people to manage your enterprise. You can also grant enterprise members the ability to manage support tickets in the support portal. For more information, see Managing support entitlements for your enterprise. ## 3. Viewing people in your enterprise To audit access to enterprise-owned resources or user license usage, you can view every enterprise administrator, enterprise member, and outside collaborator in your enterprise. You can see the organizations that a member belongs to and the specific repositories that an outside collaborator has access to. For more information, see Viewing people in your enterprise. ## Part 3: Managing security with GitHub Enterprise Cloud Managing security with Enterprise Managed Users Managing security without Enterprise Managed Users ## Managing security with Enterprise Managed Users With Enterprise Managed Users, access and identity is managed centrally through your identity provider. Two-factor authentication and other access requirements should be enabled and enforced on your IdP. ## 1. Enabling SAML single sign-on and provisioning in your enterprise with managed users In an enterprise with managed users, all members are provisioned and managed by your identity provider. You must enable SSO and SCIM provisioning before you can start using your enterprise. For more information, see Getting started with Enterprise Managed Users. ## 2. Managing organization and team membership in your enterprise with managed users with your identity provider To manage organization and team membership within your enterprise from your IdP, you can connect teams in your organizations to security groups in your identity provider. For more information, see Managing team memberships with identity provider groups. ## 3. Managing allowed IP addresses for organizations in your enterprise with managed users You can configure an allow list for specific IP addresses to restrict access to assets owned by organizations in your enterprise with managed users. For more information, see Enforcing policies for security settings in your enterprise. ## 4. Enforcing policies for GitHub Advanced Security features in your enterprise with managed users If you use GitHub Secret Protection or GitHub Code Security for your enterprise, you can enforce policies to manage Secret Protection and Code Security features for organizations owned by an enterprise account. For more information, see Enforcing policies for code security and analysis for your enterprise. ## Managing security without Enterprise Managed Users To manage security for your enterprise, you can require two-factor authentication, manage allowed IP addresses, enable SAML single sign-on and team synchronization, and sign up for and enforce GitHub Advanced Security features. ## 1. Requiring two-factor authentication and managing allowed IP addresses for organizations in your enterprise account Enterprise owners can require that organization members, billing managers, and outside collaborators in all organizations owned by an enterprise account use two-factor authentication to secure their personal accounts. Before doing so, we recommend notifying all who have access to organizations in your enterprise. You can also configure an allow list for specific IP addresses to restrict access to assets owned by organizations in your enterprise account. For more information about enforcing two-factor authentication and allowed IP address lists, see Enforcing policies for security settings in your enterprise. ## 2. Enabling and enforcing SAML single sign-on for organizations in your enterprise account You can centrally manage access to your enterprise's resources from your IdP using SAML single sign-on (SSO). Enterprise owners can enable SAML SSO across all organizations owned by an enterprise account. For more information, see About SAML for enterprise IAM. ## 3. Managing team synchronization You can enable and manage team synchronization between an identity provider (IdP) and GitHub to allow organizations owned by your enterprise account to manage team membership with IdP groups. For more information, see Managing team synchronization for organizations in your enterprise. ## 4. Enforcing policies for GitHub Advanced Security features in your enterprise account If you use GitHub Secret Protection or GitHub Code Security for your enterprise, you can enforce policies to manage Secret Protection and Code Security features for organizations owned by an enterprise account. For more information, see Enforcing policies for code security and analysis for your enterprise. ## Part 4: Managing organization and enterprise level policies and settings To manage and moderate your enterprise, you can set policies for organizations within the enterprise, view audit logs, configure webhooks, and restrict email notifications. ## 1. Managing policies for organizations in your enterprise account You can choose to enforce a number of policies for all organizations owned by your enterprise, or choose to allow these policies to be set in each organization. Types of policies you can enforce include repository management, projects, and team policies. For more information, see Setting policies for your enterprise. ## 2. Viewing audit logs, configuring webhooks, and restricting email notifications for your enterprise You can view actions from all of the organizations owned by your enterprise account in the enterprise audit log. You can also configure webhooks to receive events from organizations owned by your enterprise account. For more information, see Reviewing audit logs for your enterprise and Monitoring activity in your enterprise. You can also restrict email notifications for your enterprise account so that enterprise members can only use an email address in a verified or approved domain to receive notifications. For more information, see Restricting email notifications for your enterprise. ## Part 5: Customizing and automating your enterprise's work on GitHub Members of your organization or enterprise can use tools from the GitHub Marketplace, the GitHub API, and existing GitHub features to customize and automate your work. ## 1. Using GitHub Marketplace GitHub Marketplace contains integrations that add functionality and improve your workflow. You can discover, browse, and install free and paid tools, including GitHub Apps, OAuth apps, and GitHub Actions, in GitHub Marketplace. ## 2. Using the GitHub API There are two versions of the GitHub API: the REST API and the GraphQL API. You can use the GitHub APIs to automate common tasks, back up your data, or create integrations that extend GitHub. For more information, see Comparing GitHub's REST API and GraphQL API. ## 3. Building GitHub Actions With GitHub Actions, you can automate and customize your enterprise's development workflow on GitHub. You can create your own actions, and use and customize actions shared by the GitHub community. For more information, see Writing workflows. ## 4. Publishing and managing GitHub Packages GitHub Packages is a software package hosting service that allows you to host your software packages privately or publicly and use packages as dependencies in your projects. For more information, see Introduction to GitHub Packages. ## 5. Using GitHub Pages GitHub Pages is a static site hosting service that takes HTML, CSS, and JavaScript files straight from a repository and publishes a website. You can manage the publication of GitHub Pages sites at the organization level. For more information, see Managing the publication of GitHub Pages sites for your organization and What is GitHub Pages?. ## Part 6: Participating in GitHub's community You and your enterprise members can use GitHub's learning and support resources to get the help they need. You can also support the open source community. ## 1. Reading about GitHub Enterprise Cloud on GitHub Docs You can read documentation that reflects the features available with GitHub Enterprise Cloud. For more information, see About versions of GitHub Docs. To learn how your enterprise can use GitHub most effectively, see Best practices for enterprises. ## 2. Learning with GitHub Skills Enterprise members can learn new skills by completing fun, realistic projects in your very own GitHub repository with GitHub Skills. Each course is a hands-on lesson created by the GitHub community and taught by a friendly bot. For more information, see Git and GitHub learning resources. ## 3. Supporting the open source community GitHub Sponsors allows you to make a monthly recurring payment to a developer or organization who designs, creates, or maintains open source projects you depend on. For more information, see About GitHub Sponsors. ## 4. Contacting GitHub Support GitHub Support can help you troubleshoot issues you run into while using GitHub. For more information, see About GitHub Support. GitHub Enterprise Cloud allows you to submit priority support requests with a target eight-hour response time. For more information, see About GitHub Support. ## Further reading Feature overview for GitHub Enterprise Cloud",
    "url": "https://docs.github.com/en/get-started/onboarding/getting-started-with-github-enterprise-cloud",
    "section": "Getting Started",
    "word_count": 1982
  },
  {
    "title": "Forking and cloning gists",
    "content": "## Forking and cloning gists Gists are actually Git repositories, which means that you can fork or clone any gist, even if you aren't the original author. You can also view a gist's full commit history, including diffs. ## In this article ## Forking gists Each gist indicates which forks have activity, making it easy to find interesting changes from others. ## Cloning gists If you want to make local changes to a gist and push them up to the web, you can clone a gist and make commits the same as you would with any Git repository. For more information, see Cloning a repository. To clone a gist, select the Embed dropdown menu, then click Clone via HTTPS or Clone via SSH. ## Viewing gist commit history To view a gist's full commit history, click the \"Revisions\" tab at the top of the gist. You will see a full commit history for the gist with diffs.",
    "url": "https://docs.github.com/en/get-started/writing-on-github/editing-and-sharing-content-with-gists/forking-and-cloning-gists",
    "section": "Getting Started",
    "word_count": 157
  },
  {
    "title": "Using GitHub Copilot to explore projects",
    "content": "## Using GitHub Copilot to explore projects This guide will help you use Copilot to explore projects on GitHub. ## In this article In this guide, you’ll learn how to use Copilot Chat in GitHub to understand a repository’s purpose, examine files, and dive into specific lines of code. By following these steps, you’ll gain insights into any project faster—making onboarding, code review, and project exploration easier and more efficient. ## Prerequisites You'll need access to GitHub Copilot. For more information, see What is GitHub Copilot?. ## Understanding a repository When you’re new to a project, it can be challenging to understand the purpose of a repository and its files. Copilot can help you quickly understand the purpose of a repository, for example, by providing a summary of the repository’s README file. On the GitHub website, go to the repository you want to chat about. On the GitHub website, go to the repository you want to chat about. Click the GitHub Copilot icon at the top right of the page. Click the GitHub Copilot icon at the top right of the page. The heading at the top of the chat panel should read \"Chatting about\" followed by the name of the current repository. If the wrong repository name is displayed, because you were previously chatting about another repository, click All repositories then choose the repository you want to chat about. The heading at the top of the chat panel should read \"Chatting about\" followed by the name of the current repository. If the wrong repository name is displayed, because you were previously chatting about another repository, click All repositories then choose the repository you want to chat about. In the \"Ask Copilot\" box, at the bottom of the chat panel, type \"Summarize the purpose of this repository based on the README\" and press Enter. Copilot replies in the chat panel. In the \"Ask Copilot\" box, at the bottom of the chat panel, type \"Summarize the purpose of this repository based on the README\" and press Enter. Copilot replies in the chat panel. You can also use Copilot to understand the roles of different folders and files within the repository. For example, you can ask Copilot to summarize the contents of a specific file, or to explain the purpose of a specific folder. ## Exploring files and code When you’re exploring a project, you might want to understand the contents of a specific file. Copilot can help you quickly understand the purpose of a file, for example, by providing a summary of the file’s contents. You can also ask Copilot to explain specific lines of code within a file. On GitHub, navigate to a repository and open a file. On GitHub, navigate to a repository and open a file. Do one of the following: To ask a question about the entire file, click the Copilot icon () at the top right of the file view. To ask a question about specific lines within the file: Click the line number for the first line you want to ask about, hold down Shift, then click the line number for the last line you want to select. To ask your own question about the selected lines, click the Copilot icon () to the right of your selection, then type your question in the GitHub Copilot Chat panel. To ask a predefined question, click the drop-down menu beside the Copilot icon, then choose one of the options. Do one of the following: To ask a question about the entire file, click the Copilot icon () at the top right of the file view. To ask a question about the entire file, click the Copilot icon () at the top right of the file view. To ask a question about specific lines within the file: Click the line number for the first line you want to ask about, hold down Shift, then click the line number for the last line you want to select. To ask your own question about the selected lines, click the Copilot icon () to the right of your selection, then type your question in the GitHub Copilot Chat panel. To ask a predefined question, click the drop-down menu beside the Copilot icon, then choose one of the options. To ask a question about specific lines within the file: Click the line number for the first line you want to ask about, hold down Shift, then click the line number for the last line you want to select. To ask your own question about the selected lines, click the Copilot icon () to the right of your selection, then type your question in the GitHub Copilot Chat panel. To ask a predefined question, click the drop-down menu beside the Copilot icon, then choose one of the options. If you clicked the Copilot icon, type a question in the \"Ask Copilot\" box at the bottom of the chat panel and press Enter. For example, if you are asking about the entire file, you could enter: Explain this file. How could I improve this code? How can I test this script? If you are asking about specific lines, you could enter: Explain the function at the selected lines. How could I improve this class? Add error handling to this code. Write a unit test for this method. Copilot responds to your request in the panel. If you clicked the Copilot icon, type a question in the \"Ask Copilot\" box at the bottom of the chat panel and press Enter. For example, if you are asking about the entire file, you could enter: Explain this file. Explain this file. How could I improve this code? How could I improve this code? How can I test this script? How can I test this script? If you are asking about specific lines, you could enter: Explain the function at the selected lines. Explain the function at the selected lines. How could I improve this class? How could I improve this class? Add error handling to this code. Add error handling to this code. Write a unit test for this method. Write a unit test for this method. Copilot responds to your request in the panel. Optionally, after submitting a question, you can click in the text box to stop the response. Optionally, after submitting a question, you can click in the text box to stop the response. You can continue the conversation by asking a follow-up question. For example, you could type \"tell me more\" to get Copilot to expand on its last comment. You can continue the conversation by asking a follow-up question. For example, you could type \"tell me more\" to get Copilot to expand on its last comment. ## Further reading Using GitHub Copilot to explore a codebase Now that you know how to use Copilot to explore projects, you can use it to help you understand any repository, file, or line of code on GitHub.",
    "url": "https://docs.github.com/en/get-started/exploring-projects-on-github/using-github-copilot-to-explore-projects",
    "section": "Getting Started",
    "word_count": 1152
  },
  {
    "title": "Get started with GitHub documentation",
    "content": "About GitHub and GitYou can use GitHub and Git to collaborate on work. ## About GitHub and Git You can use GitHub and Git to collaborate on work. GitHub’s plansAn overview of GitHub's pricing plans. ## GitHub’s plans An overview of GitHub's pricing plans. Getting started with your GitHub accountWith a personal account on GitHub, you can import or create repositories, collaborate with others, and connect with the GitHub community. ## Getting started with your GitHub account With a personal account on GitHub, you can import or create repositories, collaborate with others, and connect with the GitHub community. Getting started with GitHub TeamWith GitHub Team groups of people can collaborate across many projects at the same time in an organization account. ## Getting started with GitHub Team With GitHub Team groups of people can collaborate across many projects at the same time in an organization account. Creating an account on GitHubCreate a personal account to get started with GitHub. ## Creating an account on GitHub Create a personal account to get started with GitHub. Hello WorldFollow this Hello World exercise to learn GitHub's pull request workflow. ## Hello World Follow this Hello World exercise to learn GitHub's pull request workflow. Set up GitAt the heart of GitHub is an open-source version control system (VCS) called Git. Git is responsible for everything GitHub-related that happens locally on your computer. At the heart of GitHub is an open-source version control system (VCS) called Git. Git is responsible for everything GitHub-related that happens locally on your computer. About versions of GitHub DocsYou can read documentation that reflects the GitHub product you're currently using. ## About versions of GitHub Docs You can read documentation that reflects the GitHub product you're currently using. Types of GitHub accountsAccounts on GitHub allow you to organize and control access to code. ## Types of GitHub accounts Accounts on GitHub allow you to organize and control access to code. Finding ways to contribute to open source on GitHubYou can find ways to contribute to open source projects on GitHub that are relevant to you. ## Finding ways to contribute to open source on GitHub You can find ways to contribute to open source projects on GitHub that are relevant to you. Troubleshooting connectivity problemsIf you're having trouble connecting to GitHub, you can troubleshoot your connection, then use the GitHub Debug tool to diagnose problems. ## Troubleshooting connectivity problems If you're having trouble connecting to GitHub, you can troubleshoot your connection, then use the GitHub Debug tool to diagnose problems. ## All Get started docs ## Start your journey About GitHub and Git Creating an account on GitHub Hello World Setting up your profile Finding inspiration on GitHub Downloading files from GitHub Uploading a project to GitHub Git and GitHub learning resources Getting started with your GitHub account Getting started with GitHub Team Getting started with the GitHub Enterprise Cloud trial Getting started with GitHub Enterprise Cloud ## Using GitHub GitHub flow Connecting to GitHub Communicating on GitHub Exploring early access releases with feature preview Supported browsers GitHub Mobile Allowing access to GitHub's services from a restricted network Troubleshooting connectivity problems ## Learning about GitHub GitHub’s plans GitHub language support Types of GitHub accounts Access permissions on GitHub About GitHub Advanced Security FAQ about changes to GitHub’s plans GitHub glossary ## Learning to code Getting started with Git Finding and understanding example code Reusing other people's code in your projects Setting up Copilot for learning to code Developing your project locally Learning to debug with GitHub Copilot Storing your secrets safely Getting feedback on your code from GitHub Copilot Finding and fixing your first code vulnerability Finding and fixing your first dependency vulnerability ## Accessibility Managing your theme settings Keyboard shortcuts GitHub Command Palette ## Writing on GitHub Getting started with writing and formatting on GitHub • 3 articles Working with advanced formatting • 10 articles Working with saved replies • 5 articles Editing and sharing content with gists • 4 articles ## Exploring projects on GitHub Finding ways to contribute to open source on GitHub Contributing to open source Using GitHub Copilot to explore projects Contributing to a project Saving repositories with stars Following people Following organizations Setting your username in Git Caching your GitHub credentials in Git Why is Git always asking for my password? Updating credentials from the macOS Keychain Git workflows About remote repositories Managing remote repositories Associating text editors with Git Configuring Git to handle line endings Ignoring files Git cheatsheet Pushing commits to a remote repository Getting changes from a remote repository Dealing with non-fast-forward errors Splitting a subfolder out into a new repository About Git subtree merges About Git rebase Using Git rebase on the command line Resolving merge conflicts after a Git rebase Dealing with special characters in branch and tag names Troubleshooting the 2 GB push limit ## Exploring integrations About using integrations About building integrations Featured GitHub integrations GitHub Developer Program ## Archiving your GitHub personal account and public repositories Requesting an archive of your personal account’s data Opting into or out of the GitHub Archive Program for your public repository ## Using GitHub Docs About versions of GitHub Docs Using hover cards on GitHub Docs ## Showcase your expertise with GitHub Certifications About GitHub Certifications Registering for a GitHub Certifications exam",
    "url": "https://docs.github.com/en/get-started",
    "section": "Getting Started",
    "word_count": 882
  },
  {
    "title": "Ignoring files",
    "content": "## Ignoring files You can configure Git to ignore files you don't want to check in to GitHub. ## Platform navigation ## In this article ## Configuring ignored files for a single repository You can create a .gitignore file in your repository's root directory to tell Git which files and directories to ignore when you make a commit. To share the ignore rules with other users who clone the repository, commit the .gitignore file in to your repository. GitHub maintains an official list of recommended .gitignore files for many popular operating systems, environments, and languages in the \"github/gitignore\" public repository. You can also use gitignore.io to create a .gitignore file for your operating system, programming language, or IDE. For more information, see github/gitignore and the gitignore.io site. Open TerminalTerminalGit Bash. Open TerminalTerminalGit Bash. Navigate to the location of your Git repository. Navigate to the location of your Git repository. Create a .gitignore file for your repository. touch .gitignore If the command succeeds, there will be no output. Create a .gitignore file for your repository. touch .gitignore touch .gitignore If the command succeeds, there will be no output. For an example .gitignore file, see Some common .gitignore configurations in the Octocat repository. If you want to ignore a file that is already checked in, you must untrack the file before you add a rule to ignore it. From your terminal, untrack the file. git rm --cached FILENAME git rm --cached FILENAME ## Configuring ignored files for all repositories on your computer You can tell Git to always ignore certain files or directories when you make a commit in any Git repository on your computer. For example, you could use this feature to ignore any temporary backup files that your text editor creates. To always ignore a certain file or directory, add it to a file named ignore that's located inside the directory ~/.config/git. By default, Git will ignore any files and directories that are listed in the global configuration file ~/.config/git/ignore. If the git directory and ignore file don't exist yet, you may need to create them. ~/.config/git ~/.config/git/ignore ## Excluding local files without creating a .gitignore file If you don't want to create a .gitignore file to share with others, you can create rules that are not committed with the repository. You can use this technique for locally-generated files that you don't expect other users to generate, such as files created by your editor. Use your favorite text editor to open the file called .git/info/exclude within the root of your Git repository. Any rule you add here will not be checked in, and will only ignore files for your local repository. .git/info/exclude Open TerminalTerminalGit Bash. Navigate to the location of your Git repository. Using your favorite text editor, open the file .git/info/exclude. .git/info/exclude ## Further Reading Ignoring files in the Git documentation .gitignore in the Git documentation A collection of useful .gitignore templates in the github/gitignore repository gitignore.io site",
    "url": "https://docs.github.com/en/get-started/git-basics/ignoring-files",
    "section": "Getting Started",
    "word_count": 489
  },
  {
    "title": "Access permissions on GitHub",
    "content": "## Access permissions on GitHub With roles, you can control who has access to your accounts and resources and the level of access each person has. ## In this article ## About access permissions on GitHub To perform any actions on GitHub, such as creating a pull request in a repository or changing an organization's billing settings, a person must have sufficient access to the relevant account or resource. This access is controlled by permissions. A permission is the ability to perform a specific action. For example, the ability to delete an issue is a permission. A role is a set of permissions you can assign to individuals or teams. Roles work differently for different types of accounts. For more information about accounts, see Types of GitHub accounts. ## Personal accounts A repository owned by a personal account has two permission levels: the repository owner and collaborators. For more information, see Permission levels for a personal account repository. ## Organization accounts Organization members can have owner, billing manager, or member roles. Owners have complete administrative access to your organization, while billing managers can manage billing settings. Member is the default role for everyone else. You can manage access permissions for multiple members at a time with teams. For more information, see: Roles in an organization Repository roles for an organization About teams ## Enterprise accounts Enterprise accounts are available with GitHub Enterprise Cloud and GitHub Enterprise Server. For more information, see About enterprise accounts in the GitHub Enterprise Cloud documentation. For more information about permissions for enterprise accounts, see the GitHub Enterprise Cloud documentation. ## Further reading Types of GitHub accounts",
    "url": "https://docs.github.com/en/get-started/learning-about-github/access-permissions-on-github",
    "section": "Getting Started",
    "word_count": 271
  },
  {
    "title": "Setting your username in Git",
    "content": "## Setting your username in Git Git uses a username to associate commits with an identity. The Git username is not the same as your GitHub username. ## Platform navigation ## In this article ## About Git usernames You can change the name that is associated with your Git commits using the git config command. The new name you set will be visible in any future commits you push to GitHub from the command line. If you'd like to keep your real name private, you can use any text as your Git username. Changing the name associated with your Git commits using git config will only affect future commits and will not change the name used for past commits. ## Setting your Git username for every repository on your computer Open TerminalTerminalGit Bash. Open TerminalTerminalGit Bash. Set a Git username: git config --global user.name \"Mona Lisa\" Set a Git username: git config --global user.name \"Mona Lisa\" git config --global user.name \"Mona Lisa\" Confirm that you have set the Git username correctly: $ git config --global user.name > Mona Lisa Confirm that you have set the Git username correctly: $ git config --global user.name > Mona Lisa $ git config --global user.name > Mona Lisa ## Setting your Git username for a single repository Open TerminalTerminalGit Bash. Open TerminalTerminalGit Bash. Change the current working directory to the local repository where you want to configure the name that is associated with your Git commits. Change the current working directory to the local repository where you want to configure the name that is associated with your Git commits. Set a Git username: git config user.name \"Mona Lisa\" Set a Git username: git config user.name \"Mona Lisa\" git config user.name \"Mona Lisa\" Confirm that you have set the Git username correctly: $ git config user.name > Mona Lisa Confirm that you have set the Git username correctly: $ git config user.name > Mona Lisa $ git config user.name > Mona Lisa ## Further reading Setting your commit email address \"Git Configuration\" from the Pro Git book",
    "url": "https://docs.github.com/en/get-started/git-basics/setting-your-username-in-git",
    "section": "Getting Started",
    "word_count": 342
  },
  {
    "title": "Using hover cards on GitHub Docs",
    "content": "## Using hover cards on GitHub Docs Hover cards give you information about other articles on GitHub Docs. ## In this article ## About hover cards When you're reading an article on GitHub Docs and find a link to another article, you can open a hover card to get more information about the article. The hover card provides basic information about the article, so you can determine whether it will be useful to you without leaving the article you're reading. If you navigate GitHub Docs with a mouse, the hover card is displayed when you hover the cursor over a link. The card shows the article's location, title, and introduction. ## Using hover cards with a keyboard When you have placed focus on a link to an article, you can press Enter to follow the link directly, or you can press Alt+↑ (Windows/Linux) or Option+↑ (Mac) to open the hover card. With the hover card open, you can press Enter to follow the link, or you can press Esc to close the hover card.",
    "url": "https://docs.github.com/en/get-started/using-github-docs/using-hover-cards-on-github-docs",
    "section": "Getting Started",
    "word_count": 174
  },
  {
    "title": "About writing and formatting on GitHub",
    "content": "## About writing and formatting on GitHub GitHub combines a syntax for formatting text called GitHub Flavored Markdown with a few unique writing features. ## Who can use this feature? Markdown can be used in the GitHub web interface. ## In this article Markdown is an easy-to-read, easy-to-write language for formatting plain text. We've added some custom functionality to create GitHub Flavored Markdown, used to format prose and code across our site. You can also interact with other users in pull requests and issues using features like @-mentions, issue and PR references, and emoji. For more information, see Basic writing and formatting syntax. ## Text formatting toolbar Every comment field on GitHub contains a text formatting toolbar, which allows you to format your text without learning Markdown syntax. In addition to Markdown formatting like bold and italic styles and creating headers, links, and lists, the toolbar includes GitHub-specific features such as @-mentions, task lists, and links to issues and pull requests. ## Enabling fixed-width fonts in the editor You can enable a fixed-width font in every comment field on GitHub. Each character in a fixed-width, or monospace, font occupies the same horizontal space. This can make it easier to edit advanced Markdown structures such as tables and code snippets. In the upper-right corner of any page on GitHub, click your profile picture, then click Settings. In the left sidebar, click Appearance. Under \"Markdown editor font preference\", select Use a fixed-width (monospace) font when editing Markdown. ## Further reading GitHub Flavored Markdown Spec Basic writing and formatting syntax Working with advanced formatting Quickstart for writing on GitHub",
    "url": "https://docs.github.com/en/get-started/writing-on-github/getting-started-with-writing-and-formatting-on-github/about-writing-and-formatting-on-github",
    "section": "Getting Started",
    "word_count": 266
  },
  {
    "title": "Organizing information with tables",
    "content": "## Organizing information with tables You can build tables to organize information in comments, issues, pull requests, and wikis. ## Who can use this feature? Markdown can be used in the GitHub web interface. ## In this article ## Creating a table You can create tables with pipes | and hyphens -. Hyphens are used to create each column's header, while pipes separate each column. You must include a blank line before your table in order for it to correctly render. | First Header | Second Header | | ------------- | ------------- | | Content Cell | Content Cell | | Content Cell | Content Cell | | First Header | Second Header | | ------------- | ------------- | | Content Cell | Content Cell | | Content Cell | Content Cell | The pipes on either end of the table are optional. Cells can vary in width and do not need to be perfectly aligned within columns. There must be at least three hyphens in each column of the header row. | Command | Description | | --- | --- | | git status | List all new or modified files | | git diff | Show file differences that haven't been staged | | Command | Description | | --- | --- | | git status | List all new or modified files | | git diff | Show file differences that haven't been staged | If you are frequently editing code snippets and tables, you may benefit from enabling a fixed-width font in all comment fields on GitHub. For more information, see About writing and formatting on GitHub. ## Formatting content within your table You can use formatting such as links, inline code blocks, and text styling within your table: | Command | Description | | --- | --- | | `git status` | List all *new or modified* files | | `git diff` | Show file differences that **haven't been** staged | | Command | Description | | --- | --- | | `git status` | List all *new or modified* files | | `git diff` | Show file differences that **haven't been** staged | You can align text to the left, right, or center of a column by including colons : to the left, right, or on both sides of the hyphens within the header row. | Left-aligned | Center-aligned | Right-aligned | | :--- | :---: | ---: | | git status | git status | git status | | git diff | git diff | git diff | | Left-aligned | Center-aligned | Right-aligned | | :--- | :---: | ---: | | git status | git status | git status | | git diff | git diff | git diff | To include a pipe | as content within your cell, use a \\ before the pipe: | Name | Character | | --- | --- | | Backtick | ` | | Pipe | \\| | | Name | Character | | --- | --- | | Backtick | ` | | Pipe | \\| | ## Further reading GitHub Flavored Markdown Spec Basic writing and formatting syntax",
    "url": "https://docs.github.com/en/get-started/writing-on-github/working-with-advanced-formatting/organizing-information-with-tables",
    "section": "Getting Started",
    "word_count": 527
  },
  {
    "title": "GitHub’s plans",
    "content": "## GitHub’s plans An overview of GitHub's pricing plans. ## In this article ## About GitHub's plans GitHub offers free and paid plans for storing and collaborating on code. Some plans are available only to personal accounts, while other plans are available only to organization and enterprise accounts. For more information about accounts, see Types of GitHub accounts. See costs and features for each plan at GitHub Pricing. For information on planned features and products, see the GitHub public roadmap. When you read GitHub Docs, make sure to select the version that reflects your plan. For more information, see About versions of GitHub Docs. ## GitHub Free for personal accounts With GitHub Free for personal accounts, you can work with unlimited collaborators on unlimited public repositories with a full feature set, and on unlimited private repositories with a limited feature set. With GitHub Free, your personal account includes: GitHub Community Support Dependabot alerts Deployment protection rules for public repositories Two-factor authentication enforcement 500 MB GitHub Packages storage 120 GitHub Codespaces core hours per month 15 GB GitHub Codespaces storage per month GitHub Actions features: 2,000 minutes per month Deployment protection rules for public repositories 2,000 minutes per month Deployment protection rules for public repositories GitHub Pages in public repositories In addition to the features available with GitHub Free for personal accounts, GitHub Pro includes: GitHub Support via email 3,000 GitHub Actions minutes per month 2 GB GitHub Packages storage 180 GitHub Codespaces core hours per month 20 GB GitHub Codespaces storage per month Advanced tools and insights in private repositories: Required pull request reviewers Multiple pull request reviewers Protected branches Code owners Auto-linked references GitHub Pages Note To publish a GitHub Pages site privately, you need to have an organization account. Additionally, your organization must use GitHub Enterprise Cloud. Wikis Repository insights graphs: Pulse, contributors, traffic, commits, code frequency, network, and forks Note Certain contributor, commit, and code frequency insights are only available for repositories that have fewer than 10,000 commits. Required pull request reviewers Required pull request reviewers Multiple pull request reviewers Multiple pull request reviewers Protected branches Protected branches Code owners Code owners Auto-linked references Auto-linked references GitHub Pages Note To publish a GitHub Pages site privately, you need to have an organization account. Additionally, your organization must use GitHub Enterprise Cloud. GitHub Pages To publish a GitHub Pages site privately, you need to have an organization account. Additionally, your organization must use GitHub Enterprise Cloud. Repository insights graphs: Pulse, contributors, traffic, commits, code frequency, network, and forks Note Certain contributor, commit, and code frequency insights are only available for repositories that have fewer than 10,000 commits. Repository insights graphs: Pulse, contributors, traffic, commits, code frequency, network, and forks Certain contributor, commit, and code frequency insights are only available for repositories that have fewer than 10,000 commits. ## GitHub Free for organizations With GitHub Free for organizations, you can work with unlimited collaborators on unlimited public repositories with a full feature set, or unlimited private repositories with a limited feature set. In addition to the features available with GitHub Free for personal accounts, GitHub Free for organizations includes: GitHub Community Support Team access controls for managing groups 2,000 GitHub Actions minutes per month ## GitHub Team In addition to the features available with GitHub Free for organizations, GitHub Team includes: GitHub Support via email GitHub Support via email 3,000 GitHub Actions minutes per month 3,000 GitHub Actions minutes per month 2 GB GitHub Packages storage 2 GB GitHub Packages storage The option to purchase GitHub Advanced Security products: GitHub Code Security GitHub Secret Protection For more information, see About GitHub Advanced Security. The option to purchase GitHub Advanced Security products: GitHub Code Security GitHub Secret Protection For more information, see About GitHub Advanced Security. Advanced tools and insights in private repositories: Required pull request reviewers Multiple pull request reviewers Team pull request reviewers Protected branches Code owners Scheduled reminders GitHub Pages Note To publish a GitHub Pages site privately, you need to have an organization account. Additionally, your organization must use GitHub Enterprise Cloud. Wikis Security overview Repository insights graphs: Pulse, contributors, traffic, commits, code frequency, network, and forks Note Certain contributor, commit, and code frequency insights are only available for repositories that have fewer than 10,000 commits. Advanced tools and insights in private repositories: Required pull request reviewers Required pull request reviewers Multiple pull request reviewers Multiple pull request reviewers Team pull request reviewers Team pull request reviewers Protected branches Protected branches Code owners Code owners Scheduled reminders Scheduled reminders GitHub Pages Note To publish a GitHub Pages site privately, you need to have an organization account. Additionally, your organization must use GitHub Enterprise Cloud. GitHub Pages To publish a GitHub Pages site privately, you need to have an organization account. Additionally, your organization must use GitHub Enterprise Cloud. Security overview Security overview Repository insights graphs: Pulse, contributors, traffic, commits, code frequency, network, and forks Note Certain contributor, commit, and code frequency insights are only available for repositories that have fewer than 10,000 commits. Repository insights graphs: Pulse, contributors, traffic, commits, code frequency, network, and forks Certain contributor, commit, and code frequency insights are only available for repositories that have fewer than 10,000 commits. The option to enable or disable GitHub Codespaces Organization owners can choose to enable or disable GitHub Codespaces for the organization's private repositories, and can pay for the usage of members and collaborators. For more information, see Enabling or disabling GitHub Codespaces for your organization and Choosing who owns and pays for codespaces in your organization. The option to enable or disable GitHub Codespaces Organization owners can choose to enable or disable GitHub Codespaces for the organization's private repositories, and can pay for the usage of members and collaborators. For more information, see Enabling or disabling GitHub Codespaces for your organization and Choosing who owns and pays for codespaces in your organization. GitHub bills for GitHub Team on a per-user basis. For more information, see About per-user pricing. GitHub Actions usage is free for standard GitHub-hosted runners in public repositories, and for self-hosted runners. See Choosing the runner for a job. For private repositories, each GitHub account receives a quota of free minutes and storage for use with GitHub-hosted runners, depending on the account's plan. Any usage beyond the included amounts is billed to your account. ## GitHub Enterprise GitHub Enterprise includes two deployment options: GitHub Enterprise Cloud, which is hosted by GitHub in the cloud, and GitHub Enterprise Server, which is self-hosted. For more information, see About GitHub for enterprises in the GitHub Enterprise Cloud documentation. In addition to the features available with GitHub Team, GitHub Enterprise includes: GitHub Enterprise Support Additional security, compliance, and deployment controls Authentication with SAML single sign-on Access provisioning with SAML or SCIM Deployment protection rules with GitHub Actions for private or internal repositories GitHub Connect Additional features such as internal repositories and repository rules. GitHub Enterprise Cloud specifically includes: 50,000 GitHub Actions minutes per month Included minutes can be used with standard GitHub-hosted runners only. For more information about billing for larger runners, see Larger runners. 50,000 GitHub Actions minutes per month Included minutes can be used with standard GitHub-hosted runners only. For more information about billing for larger runners, see Larger runners. 50 GB GitHub Packages storage 50 GB GitHub Packages storage A service level agreement for 99.9% monthly uptime A service level agreement for 99.9% monthly uptime The option to centrally manage policy and billing for multiple GitHub organizations with an enterprise account. For more information, see About enterprise accounts. If you upgrade an existing organization to GitHub Enterprise Cloud, your enterprise account will contain your organization. For more information, see Upgrading your account's plan and Creating an enterprise account in the GitHub Enterprise Cloud documentation. The option to centrally manage policy and billing for multiple GitHub organizations with an enterprise account. For more information, see About enterprise accounts. If you upgrade an existing organization to GitHub Enterprise Cloud, your enterprise account will contain your organization. For more information, see Upgrading your account's plan and Creating an enterprise account in the GitHub Enterprise Cloud documentation. The option to provision and manage the user accounts for your developers, by using Enterprise Managed Users. For more information, see About Enterprise Managed Users. The option to provision and manage the user accounts for your developers, by using Enterprise Managed Users. For more information, see About Enterprise Managed Users. Additional features such as audit log streaming and IP allow list. For more information, see Streaming the audit log for your enterprise and Restricting network traffic to your enterprise with an IP allow list in the GitHub Enterprise Cloud documentation. Additional features such as audit log streaming and IP allow list. For more information, see Streaming the audit log for your enterprise and Restricting network traffic to your enterprise with an IP allow list in the GitHub Enterprise Cloud documentation. The option to host your company's data in a specific region, on a unique subdomain The option to host your company's data in a specific region, on a unique subdomain For a detailed list of the features available with GitHub Enterprise, see our Pricing page. To see how GitHub compares to GitLab, Bitbucket, and Jenkins, see Comparing GitHub to other DevOps solutions. You can set up trials to evaluate GitHub Enterprise Cloud and GitHub Enterprise Server. For more information, see Setting up a trial of GitHub Enterprise Cloud and Setting up a trial of GitHub Enterprise Server. ## Further reading About per-user pricing in the GitHub Enterprise Cloud documentation",
    "url": "https://docs.github.com/en/get-started/learning-about-github/githubs-plans",
    "section": "Getting Started",
    "word_count": 1590
  },
  {
    "title": "Saving repositories with stars",
    "content": "## Saving repositories with stars You can star repositories and topics to keep track of projects you find interesting and discover related content in your news feed. ## In this article You can search, sort, and filter your starred repositories and topics on your stars page. ## About stars Starring makes it easy to find a repository or topic again later. You can see all the repositories and topics you have starred by going to your stars page. You can star repositories and topics to discover similar projects on GitHub. For example, after you star GitHub's Green Software Directory, you will see other content related to green software on your personal dashboard. Starring a repository also shows appreciation to the repository maintainer for their work. Many of GitHub's repository rankings depend on the number of stars a repository has. In addition, Explore GitHub shows popular repositories based on the number of stars they have. ## Starring a repository Starring a repository is a simple two-step process. On GitHub, navigate to the main page of the repository. In the top-right corner of the page, click Star. Optionally, to unstar a previously starred repository, click Starred. This will remove the repository from your starred list. ## Viewing who has starred a repository You can view everyone who has starred a public repository or a private repository you have access to. To view everyone who has starred a repository, add /stargazers to the end of the URL of a repository. For example, to view stargazers for the github/docs repository, visit https://github.com/github/docs/stargazers. /stargazers ## Organizing starred repositories with lists Lists are currently in public preview and subject to change. Curate repositories that you've starred with public lists. You can create public lists that appear on your stars page at https://github.com/USERNAME?tab=stars. https://github.com/USERNAME?tab=stars If you add a private repository to a list, then the private repository will only appear in your list for people with read access to the repository. You can add a repository to an existing or new list wherever you see a repository's Star or Starred dropdown menu, whether on a repository page or in a list of starred repositories. ## Creating a list In the upper-right corner of any page, click your profile picture, then click Your stars. In the upper-right corner of any page, click your profile picture, then click Your stars. Next to \"Lists\", click Create list. Next to \"Lists\", click Create list. Enter a name and description for your list and click Create. Enter a name and description for your list and click Create. ## Adding a repository to a list In the upper-right corner of any page, click your profile picture, then click Your stars. In the upper-right corner of any page, click your profile picture, then click Your stars. Find the repository you want to add to your list by typing it into the search bar. Find the repository you want to add to your list by typing it into the search bar. Next to the repository you want to add, use the Starred dropdown menu and select your list. Next to the repository you want to add, use the Starred dropdown menu and select your list. ## Removing a repository from your list In the upper-right corner of any page, click your profile picture, then click Your stars. In the upper-right corner of any page, click your profile picture, then click Your stars. Select your list. Select your list. Next to the repository you want to remove, use the Starred drop-down menu and deselect your list. Next to the repository you want to remove, use the Starred drop-down menu and deselect your list. ## Editing a list name or description In the upper-right corner of any page, click your profile picture, then click Your stars. In the upper-right corner of any page, click your profile picture, then click Your stars. Select the list you want to edit. Select the list you want to edit. Click Edit list. Click Edit list. Update the name or description and click Save list. Update the name or description and click Save list. ## Deleting a list In the upper-right corner of any page, click your profile picture, then click Your stars. In the upper-right corner of any page, click your profile picture, then click Your stars. Select the list you want to delete. Select the list you want to delete. Click Delete list. Click Delete list. To confirm, click Delete. To confirm, click Delete. ## Searching starred repositories and topics You can use the search bar on your stars page to quickly find repositories and topics you've starred. In the upper-right corner of any page, click your profile picture, then click Your stars. In the upper-right corner of any page, click your profile picture, then click Your stars. Use the search bar to find your starred repositories or topics by their name. Use the search bar to find your starred repositories or topics by their name. The search bar only searches based on the name of a repository or topic, and not on any other qualifiers (such as the size of the repository or when it was last updated). ## Sorting and filtering stars on your stars page You can use sorting or filtering to customize how you see starred repositories and topics on your stars page. In the upper-right corner of any page, click your profile picture, then click Your stars. In the upper-right corner of any page, click your profile picture, then click Your stars. To sort stars, select the Sort by: dropdown menu, then select Recently starred, Recently active, or Most stars. To sort stars, select the Sort by: dropdown menu, then select Recently starred, Recently active, or Most stars. To filter your list of stars based on their language, click on the desired language under the Language dropdown menu. To filter your list of stars based on their language, click on the desired language under the Language dropdown menu. To filter your list of stars based on repository type, click on the desired option under the Type: dropdown menu. To filter your list of stars based on repository type, click on the desired option under the Type: dropdown menu. ## Further reading Classifying your repository with topics",
    "url": "https://docs.github.com/en/get-started/exploring-projects-on-github/saving-repositories-with-stars",
    "section": "Getting Started",
    "word_count": 1041
  },
  {
    "title": "Finding and fixing your first dependency vulnerability",
    "content": "## Finding and fixing your first dependency vulnerability Learn how to keep your dependencies secure by enabling Dependabot and its features in a demo repository. ## In this article Using pre-written collections of code in your project, called libraries or packages, is common practice. These code modules save you a ton of time, letting you focus on the new, creative aspects of your work instead of coding large reusable components from scratch. When added to your project, they are called dependencies, since your work is dependent on the code they contain. While using dependencies is perfectly normal, dependencies can contain code vulnerabilities, which would in turn make your project insecure. Luckily, tools like Dependabot can find dependency vulnerabilities, raise pull requests to fix them, and even prevent them from happening in the future. In this tutorial, you'll learn how to enable and use Dependabot and its features to keep your dependencies secure. ## Setting up the demo repository Let's get started by forking a demo project with some dependency vulnerabilities. Since we won't deploy the project, there is no security risk in this exercise. Navigate to the new2code/dependabot-demo repository. new2code/dependabot-demo In the top right of the page, click Fork. On the page that appears, click Create fork. ## Enabling dependency security features Now that we've set up the project, let's configure Dependabot to find and create fixes for insecure dependencies. In the navigation bar for your repository, click Security. In the \"Dependabot alerts\" row, click Enable Dependabot alerts. In the \"Dependabot\" section, next to \"Dependabot alerts\", click Enable. In the pop up that appears, read the statement about enabling the dependency graph, then click Enable. To allow Dependabot to automatically open pull requests fixing dependency vulnerabilities, next to \"Dependabot security updates\", click Enable. ## Viewing your insecure dependencies With Dependabot configured, let's find out which of our dependencies contain vulnerabilities. In the navigation bar for your repository, click Security. To see the Dependabot alerts for your repository, in the side navigation, click Dependabot. To see detailed information about an alert, click the alert title. For this exercise, click Command Injection in hot-formula-parser. ## Understanding a Dependabot alert Now that Dependabot has identified some vulnerabilities in our dependencies, let's break down the information provided in the \"Command Injection in hot-formula-parser\" alert. ## Fix summary Below the title of the alert, you can see a short summary of the fix for this vulnerability, including the number of alerts it will close and the location of the vulnerability. In our case, the alert tells us that upgrading the hot-formula-parser package to version 3.0.1 will fix one Dependabot alert identified in our javascript/package-lock.json file. hot-formula-parser javascript/package-lock.json This section also tracks Dependabot's progress creating a pull request to fix the vulnerability. Once a fix is available, you'll see a button labeled \" Review security update\" linking to the pull request. ## Vulnerability details Below the fix details, Dependabot provides more information about the vulnerability, including: The name of the vulnerable package The versions of the package that contain the vulnerability The version of the package that fixes the vulnerability Details on the type of vulnerability and how it can be exploited In this alert, we can see that the parse function in the hot-formula-parser package doesn't properly check that user input is safe before executing it, which allows attackers to run malicious commands. hot-formula-parser If you don't fully understand the vulnerability details, try asking Copilot Chat to explain them. Finally, you can see the timeline of the alert at the bottom of the page. Our timeline currently contains the timestamp when Dependabot opened the alert, and will be updated automatically when we fix the vulnerability. ## Securing your dependencies To secure our project quickly and easily, let's apply the fix Dependabot created. In the alert field with the fix summary, click Review security update. In the alert field with the fix summary, click Review security update. On the pull request page, click Files changed to see Dependabot's changes. After you review the changes, click Conversation to return to the pull request overview. On the pull request page, click Files changed to see Dependabot's changes. After you review the changes, click Conversation to return to the pull request overview. To apply the fix, at the bottom of the page, click Merge pull request, then click Confirm merge. Once the pull request merges, the linked Dependabot alert will close automatically, and the fix time will be added to the timeline. To apply the fix, at the bottom of the page, click Merge pull request, then click Confirm merge. Once the pull request merges, the linked Dependabot alert will close automatically, and the fix time will be added to the timeline. ## Preventing future dependency vulnerabilities To help avoid insecure dependencies moving forward, let's allow Dependabot to automatically open pull requests updating your dependencies as new versions are released. In the navigation bar for your repository, click Settings. In the \"Security\" section of the sidebar, click Advanced Security. Next to \"Dependabot version updates\", click Enable. Now that you've tried out Dependabot and its features on a demo repository, enable them on your own projects to easily find, fix, and prevent dependency vulnerabilities.",
    "url": "https://docs.github.com/en/get-started/learning-to-code/finding-and-fixing-your-first-dependency-vulnerability",
    "section": "Getting Started",
    "word_count": 864
  },
  {
    "title": "About versions of GitHub Docs",
    "content": "## About versions of GitHub Docs You can read documentation that reflects the GitHub product you're currently using. ## In this article ## About versions of GitHub Docs GitHub offers different plans for storing and collaborating on code. The plan you use determines which features are available to you. For more information, see GitHub’s plans. This website, GitHub Docs, provides documentation for all of GitHub's plans. If the content you're reading applies to more than one plan, you can choose the version of the documentation that's relevant to you by selecting the plan you're currently using. At the top of a page on GitHub Docs, select the dropdown menu and click a plan. If your browser window is not wide enough to display the full navigation bar, you may need to click first. You can try changing the version now. You're viewing the Free, Pro, & Team version of this article. ## Determining which GitHub product you use You can determine which GitHub plan you're currently using by reviewing the URL in the address bar of your browser and the heading for the GitHub website you're on. You may use more than one GitHub plan. For example, you might contribute to open source on GitHub.com and collaborate on code on your employer's GitHub Enterprise Server instance. You may need to view different versions of the same article at different times, depending on the problem you're currently trying to solve. ## GitHub.com plans or GitHub Enterprise Cloud If you access GitHub at https://github.com, you're either using the features of a Free, Pro, or Team plan, or you're using GitHub Enterprise Cloud. On GitHub.com, each account has its own plan. Each personal account has an associated plan that provides access to certain features, and each organization has a different associated plan. If your personal account is a member of an organization on GitHub, you may have access to different features when you use resources owned by that organization than when you use resources owned by your personal account. For more information, see Types of GitHub accounts. If you don't know whether an organization uses GitHub Enterprise Cloud, ask an organization owner. For more information, see Viewing people's roles in an organization. If you access GitHub at a subdomain of GHE.com, such as octocorp.ghe.com, you're part of an enterprise that uses GitHub Enterprise Cloud with data residency. You should use the \"GitHub Enterprise Cloud\" version of GitHub Docs. octocorp.ghe.com Because you're using a managed user account, certain parts of the documentation may not apply to you. See Abilities and restrictions of managed user accounts. If you see references to \"github.com\" in the documentation, you may need to substitute these references for your enterprise's subdomain on GHE.com. For example, you will make API calls to https://api.SUBDOMAIN.ghe.com, rather than https://api.github.com. https://api.SUBDOMAIN.ghe.com https://api.github.com ## GitHub Enterprise Server If you access GitHub at a URL other than https://github.com, https://*.github.us, or https://*.ghe.com, you're using GitHub Enterprise Server. For example, you may access GitHub Enterprise Server at https://github.YOUR-COMPANY-NAME.com. Your administrators may choose a URL that doesn't include the word \"GitHub.\" https://*.github.us https://*.ghe.com https://github.YOUR-COMPANY-NAME.com In a wide browser window, the word \"Enterprise\" immediately follows the GitHub logo on the left side of the header. You can view the version of GitHub Enterprise Server that you're using in the footer of any page.",
    "url": "https://docs.github.com/en/get-started/using-github-docs/about-versions-of-github-docs",
    "section": "Getting Started",
    "word_count": 552
  },
  {
    "title": "Git basics",
    "content": "Set up Git, a distributed version control system, to manage your GitHub repositories from your computer. At the heart of GitHub is an open-source version control system (VCS) called Git. Git is responsible for everything GitHub-related that happens locally on your computer. ## Setting your username in Git Git uses a username to associate commits with an identity. The Git username is not the same as your GitHub username. ## Caching your GitHub credentials in Git If you're cloning GitHub repositories using HTTPS, we recommend you use GitHub CLI or Git Credential Manager (GCM) to remember your credentials. ## Why is Git always asking for my password? If Git prompts you for a username and password every time you try to interact with GitHub, you're probably using the HTTPS clone URL for your repository. ## Updating credentials from the macOS Keychain You'll need to update your saved credentials in the git-credential-osxkeychain helper if you change your username, password, or personal access token on GitHub. git-credential-osxkeychain ## Git workflows GitHub flow is a lightweight, branch-based workflow that supports teams and projects that deploy regularly. ## About remote repositories GitHub's collaborative approach to development depends on publishing commits from your local repository to GitHub for other people to view, fetch, and update. ## Managing remote repositories Learn to work with your local repositories on your computer and remote repositories hosted on GitHub. ## Associating text editors with Git Use a text editor to open and edit your files with Git. ## Configuring Git to handle line endings To avoid problems in your diffs, you can configure Git to properly handle line endings. ## Ignoring files You can configure Git to ignore files you don't want to check in to GitHub. ## Git cheatsheet This Git cheat sheet is a time saver when you forget a command or don't want to use help in the CLI.",
    "url": "https://docs.github.com/en/get-started/git-basics",
    "section": "Getting Started",
    "word_count": 313
  },
  {
    "title": "Setting up your profile",
    "content": "## Setting up your profile Your profile tells people who you are and what you're interested in. ## In this article ## About your profile Your profile page on GitHub is a place where people can find out more about you. You can use your profile to: Share your interests and skills. Showcase your projects and contributions. Express your identity and show the GitHub community who you are. In this tutorial, you'll learn how to personalize your profile by adding a profile picture, bio, and a profile README. You'll also learn the basics of Markdown syntax, which is what you'll use to format any writing you do on GitHub. ## Prerequisites You must have a GitHub account. For more information, see Creating an account on GitHub. ## Adding a profile picture and bio First, we'll add a picture to your profile. Your profile picture helps identify you across GitHub. ## Adding a profile picture In the upper-right corner of any page, click your existing profile avatar, then, from the dropdown menu, click Settings. In the upper-right corner of any page, click your existing profile avatar, then, from the dropdown menu, click Settings. Under \"Profile Picture\", select Edit, then click Upload a photo.... Under \"Profile Picture\", select Edit, then click Upload a photo.... Select an image, then click Upload. Select an image, then click Upload. Crop your picture. Crop your picture. Click Set new profile picture. Click Set new profile picture. Next, we'll add some basic information about yourself to share with other GitHub users. This information will display below your profile picture on your profile page. ## Adding a bio On your profile page, under your profile picture, click Edit profile. On your profile page, under your profile picture, click Edit profile. Under \"Bio\", write one or two sentences about yourself, such as who you are and what you do. Note Keep the bio short; we'll add a longer description of your interests in your profile README in the section below. Under \"Bio\", write one or two sentences about yourself, such as who you are and what you do. Keep the bio short; we'll add a longer description of your interests in your profile README in the section below. To add an emoji to your bio, visit Emoji cheat sheet and copy and paste an emoji into the \"Bio\" dialog box. To add an emoji to your bio, visit Emoji cheat sheet and copy and paste an emoji into the \"Bio\" dialog box. Optionally, add your preferred pronouns, workplace, location and timezone, and any links to your personal website and social accounts. Your pronouns will only be visible to users that are signed in to GitHub. Optionally, add your preferred pronouns, workplace, location and timezone, and any links to your personal website and social accounts. Your pronouns will only be visible to users that are signed in to GitHub. Click Save. Click Save. ## Adding a profile README Next, we'll create a special repository and README file that will be displayed directly on your profile page. Your profile README contains information such as your interests, skills, and background, and it can be a great way to introduce yourself to other people on GitHub and showcase your work. As we learned in the Hello World tutorial, README.md files are written using Markdown syntax (note the .md file extension), which is just a way to format plain text. In the following steps, we'll create and edit your profile README. ## Step 1: Create a new repository for your profile README In the upper-right corner of any page, select , then click New repository. In the upper-right corner of any page, select , then click New repository. Under \"Repository name\", type a repository name that matches your GitHub username. For example, if your username is \"octocat\", the repository name must be \"octocat.\" Under \"Repository name\", type a repository name that matches your GitHub username. For example, if your username is \"octocat\", the repository name must be \"octocat.\" Optionally, in the \"Description\" field, type a description of your repository. For example, \"My personal repository.\" Optionally, in the \"Description\" field, type a description of your repository. For example, \"My personal repository.\" Select Public. Select Public. Select Initialize this repository with a README. Select Initialize this repository with a README. Click Create repository. Click Create repository. ## Step 2: Edit the README.md file Click the next to your profile README. Click the next to your profile README. In the \"Edit\" view, you'll see some pre-populated text to get you started. On line 1, delete the text that says ### Hi there and type # About me. In Markdown syntax, ### renders the plain text as a small (\"third-level\") heading, while ## or # renders a second- and first-level heading respectively. In the \"Edit\" view, you'll see some pre-populated text to get you started. On line 1, delete the text that says ### Hi there and type # About me. ### Hi there In Markdown syntax, ### renders the plain text as a small (\"third-level\") heading, while ## or # renders a second- and first-level heading respectively. Toggle to \"Preview\" to see how the plain text now renders. You should see the new text displayed as a much larger heading. Toggle to \"Preview\" to see how the plain text now renders. You should see the new text displayed as a much larger heading. Toggle back to the \"Edit\" view. Toggle back to the \"Edit\" view. Delete line 3 and line 16. This HTML syntax (e.g. <!--) is keeping the other lines hidden when you toggle to \"Preview\". Delete line 3 and line 16. This HTML syntax (e.g. <!--) is keeping the other lines hidden when you toggle to \"Preview\". Complete some of the prompts on lines 8 to 15, and delete any lines you don't want. For example, add your interests, skills, hobbies, or a fun fact about yourself. Complete some of the prompts on lines 8 to 15, and delete any lines you don't want. For example, add your interests, skills, hobbies, or a fun fact about yourself. Now, toggle to \"Preview\". You should see your completed prompts render as a bulleted list. Now, toggle to \"Preview\". You should see your completed prompts render as a bulleted list. Toggle back to \"Edit\" and remove any other lines of text that you don't want displayed on your profile. Toggle back to \"Edit\" and remove any other lines of text that you don't want displayed on your profile. Keep customizing and editing your profile README. Use the Emoji cheat sheet to add emojis. Use the Markdown cheat sheet to experiment with additional Markdown formatting. Keep customizing and editing your profile README. Use the Emoji cheat sheet to add emojis. Use the Markdown cheat sheet to experiment with additional Markdown formatting. ## Step 3: Publish your changes to your profile When you're happy with how your profile README looks in \"Preview\", and you're ready to publish it, click Commit changes... In the open dialog box, simply click again Commit changes. Navigate back to your profile page. You will see your new profile README displayed on your profile. If you want to learn more Markdown syntax and add more sophisticated formatting to your profile README, see Quickstart for writing on GitHub. Alternatively, try the GitHub Skills \"Communicate using Markdown\" course. In the next tutorial, Finding inspiration on GitHub, we'll look at ways you can explore GitHub to find projects and people that interest you. ## Further reading About your profile Personalizing your profile Basic writing and formatting syntax",
    "url": "https://docs.github.com/en/get-started/start-your-journey/setting-up-your-profile",
    "section": "Getting Started",
    "word_count": 1258
  },
  {
    "title": "Dealing with special characters in branch and tag names",
    "content": "## Dealing with special characters in branch and tag names Git is very permissive about what characters are allowed in branch and tag names. When using Git from a command-line shell, you may need to escape or quote special characters. ## In this article ## About branch and tag names Most repositories use simple branch names, such as main or update-icons. Tag names also usually follow a basic format, such as a version number like v1.2.3. Both branch names and tag names may also use the path separator (/) for structure, for example area/item or level-1/level-2/level-3. Other than some exceptions — such as not starting or ending a name with a slash, or having consecutive slashes in the name — Git has very few restrictions on what characters may be used in branch and tag names. For more information, see git-check-ref-format in the Git documentation. update-icons level-1/level-2/level-3 ## Why you need to escape special characters When using a CLI, you might have situations where a branch or tag name contains special characters that have a special meaning for your shell environment. To use these characters safely in a Git command, they must be quoted or escaped, otherwise the command may have unintended effects. For example, the $ character is used by many shells to refer to a variable. Most shells would interpret a valid branch name like hello-$USER as equivalent to the word \"hello\", followed by a hyphen, followed by the current value of the USER variable, rather than the literal string hello-$USER. If a branch name includes the $ character, then the shell must be stopped from expanding it as a variable reference. Similarly, if a branch name contains a semi-colon (;), most shells interpret it as a command separator, so it needs to be quoted or escaped. hello-$USER hello-$USER ## How to escape special characters in branch and tag names Most branch and tag names with special characters can be handled by including the name in single quotes, for example 'hello-$USER'. 'hello-$USER' In the Bash shell, enclosing a string of characters in single quotes preserves the literal value of the characters within the single quotes. Zsh behaves similar to Bash, however this behavior is configurable using the RC_QUOTES option. PowerShell also treats characters literally when inside single quotes. For these shells, the main exception is when the branch or tag name itself contains a single quote. In this case, you should consult the official documentation for your shell: Bash documentation Zsh documentation Fish documentation PowerShell documentation ## Naming branches and tags If possible, create branch and tag names that don't contain special characters, as these would need to be escaped. A safe default set of characters to use for branch names and tag names is: The English alphabet (a to z and A to Z) Numbers (0 to 9) A limited set of punctuation characters: underscore (_) forward slash (/) To avoid confusion, you should start branch names with a letter. ## Restrictions on names in GitHub GitHub restricts a small number of branch and tag names from being pushed up. Those restrictions are: No names which look like Git object IDs (40 characters containing only 0-9 and A-F), to prevent confusion with actual Git object IDs. No names beginning with refs/, to prevent confusion with the full name of Git refs. For more information about refs, see Git References in the Git documentation.",
    "url": "https://docs.github.com/en/get-started/using-git/dealing-with-special-characters-in-branch-and-tag-names",
    "section": "Getting Started",
    "word_count": 566
  },
  {
    "title": "Managing your theme settings",
    "content": "## Managing your theme settings You can manage how GitHub looks to you by setting a theme preference that either follows your system settings or always uses a light or dark mode. For choice and flexibility in how and when you use GitHub, you can configure theme settings to change how GitHub looks to you. You can choose from themes that are light or dark, or you can configure GitHub to follow your system settings. You may want to use a dark theme to reduce power consumption on certain devices, to reduce eye strain in low-light conditions, or because you prefer how the theme looks. If you have low vision, you may benefit from a high contrast theme, with greater contrast between foreground and background elements. If you have colorblindness, you may benefit from our light and dark colorblind themes. In the upper-right corner of any page on GitHub, click your profile picture, then click Settings. In the upper-right corner of any page on GitHub, click your profile picture, then click Settings. In the left sidebar, click Appearance. In the left sidebar, click Appearance. Under \"Theme mode\", select the dropdown menu, then click a theme preference. Under \"Theme mode\", select the dropdown menu, then click a theme preference. Click the theme you'd like to use. If you chose a single theme, click a theme. If you chose to follow your system settings, click a day theme and a night theme. If you would like to choose a theme which is currently in public preview, you will first need to enable it with feature preview. For more information, see Exploring early access releases with feature preview. Click the theme you'd like to use. If you chose a single theme, click a theme. If you chose a single theme, click a theme. If you chose to follow your system settings, click a day theme and a night theme. If you chose to follow your system settings, click a day theme and a night theme. If you would like to choose a theme which is currently in public preview, you will first need to enable it with feature preview. For more information, see Exploring early access releases with feature preview. If you would like to choose a theme which is currently in public preview, you will first need to enable it with feature preview. For more information, see Exploring early access releases with feature preview. You can also change your theme settings with the command palette. For more information, see GitHub Command Palette. ## Further reading Setting a theme for GitHub Desktop",
    "url": "https://docs.github.com/en/get-started/accessibility/managing-your-theme-settings",
    "section": "Getting Started",
    "word_count": 429
  },
  {
    "title": "Quickstart for writing on GitHub",
    "content": "## Quickstart for writing on GitHub Learn advanced formatting features by creating a README for your GitHub profile. ## Who can use this feature? Markdown can be used in the GitHub web interface. ## In this article ## Introduction Markdown is an easy-to-read, easy-to-write language for formatting plain text. You can use Markdown syntax, along with some additional HTML tags, to format your writing on GitHub, in places like repository READMEs and comments on pull requests and issues. In this guide, you'll learn some advanced formatting features by creating or editing a README for your GitHub profile. If you're new to Markdown, you might want to start with Basic writing and formatting syntax or the Communicate using Markdown GitHub Skills course. If you already have a profile README, you can follow this guide by adding some features to your existing README, or by creating a gist with a Markdown file called something like about-me.md. For more information, see Creating gists. about-me.md ## Creating or editing your profile README Your profile README lets you share information about yourself with the community on GitHub. The README is displayed at the top of your profile page. If you don't already have a profile README, you can add one. Create a repository with the same name as your GitHub username, initializing the repository with a README.md file. For more information, see Managing your profile README. Edit the README.md file and delete the template text (beginning ### Hi there) that is automatically added when you create the file. ### Hi there If you already have a profile README, you can edit it from your profile page. In the upper-right corner of any page, click your profile picture, then click Your profile. In the upper-right corner of any page, click your profile picture, then click Your profile. Click the next to your profile README. Click the next to your profile README. ## Adding an image to suit your visitors You can include images in your communication on GitHub. Here, you'll add a responsive image, such as a banner, to the top of your profile README. By using the HTML <picture> element with the prefers-color-scheme media feature, you can add an image that changes depending on whether a visitor is using light or dark mode. For more information, see Managing your theme settings. prefers-color-scheme Copy and paste the following markup into your README.md file. <picture> <source media=\"(prefers-color-scheme: dark)\" srcset=\"YOUR-DARKMODE-IMAGE\"> <source media=\"(prefers-color-scheme: light)\" srcset=\"YOUR-LIGHTMODE-IMAGE\"> <img alt=\"YOUR-ALT-TEXT\" src=\"YOUR-DEFAULT-IMAGE\"> </picture> Copy and paste the following markup into your README.md file. <picture> <source media=\"(prefers-color-scheme: dark)\" srcset=\"YOUR-DARKMODE-IMAGE\"> <source media=\"(prefers-color-scheme: light)\" srcset=\"YOUR-LIGHTMODE-IMAGE\"> <img alt=\"YOUR-ALT-TEXT\" src=\"YOUR-DEFAULT-IMAGE\"> </picture> <picture> <source media=\"(prefers-color-scheme: dark)\" srcset=\"YOUR-DARKMODE-IMAGE\"> <source media=\"(prefers-color-scheme: light)\" srcset=\"YOUR-LIGHTMODE-IMAGE\"> <img alt=\"YOUR-ALT-TEXT\" src=\"YOUR-DEFAULT-IMAGE\"> </picture> Replace the placeholders in the markup with the URLs of your chosen images. Alternatively, to try the feature first, you can copy the URLs from our example below. Replace YOUR-DARKMODE-IMAGE with the URL of an image to display for visitors using dark mode. Replace YOUR-LIGHTMODE-IMAGE with the URL of an image to display for visitors using light mode. Replace YOUR-DEFAULT-IMAGE with the URL of an image to display in case neither of the other images can be matched, for example if the visitor is using a browser that does not support the prefers-color-scheme feature. Replace the placeholders in the markup with the URLs of your chosen images. Alternatively, to try the feature first, you can copy the URLs from our example below. Replace YOUR-DARKMODE-IMAGE with the URL of an image to display for visitors using dark mode. YOUR-DARKMODE-IMAGE Replace YOUR-LIGHTMODE-IMAGE with the URL of an image to display for visitors using light mode. YOUR-LIGHTMODE-IMAGE Replace YOUR-DEFAULT-IMAGE with the URL of an image to display in case neither of the other images can be matched, for example if the visitor is using a browser that does not support the prefers-color-scheme feature. YOUR-DEFAULT-IMAGE prefers-color-scheme To make the image accessible for visitors who are using a screen reader, replace YOUR-ALT-TEXT with a description of the image. To make the image accessible for visitors who are using a screen reader, replace YOUR-ALT-TEXT with a description of the image. YOUR-ALT-TEXT To check the image has rendered correctly, click the Preview tab. To check the image has rendered correctly, click the Preview tab. For more information on using images in Markdown, see Basic writing and formatting syntax. ## Example of a responsive image <picture> <source media=\"(prefers-color-scheme: dark)\" srcset=\"https://user-images.githubusercontent.com/25423296/163456776-7f95b81a-f1ed-45f7-b7ab-8fa810d529fa.png\"> <source media=\"(prefers-color-scheme: light)\" srcset=\"https://user-images.githubusercontent.com/25423296/163456779-a8556205-d0a5-45e2-ac17-42d089e3c3f8.png\"> <img alt=\"Shows an illustrated sun in light mode and a moon with stars in dark mode.\" src=\"https://user-images.githubusercontent.com/25423296/163456779-a8556205-d0a5-45e2-ac17-42d089e3c3f8.png\"> </picture> <picture> <source media=\"(prefers-color-scheme: dark)\" srcset=\"https://user-images.githubusercontent.com/25423296/163456776-7f95b81a-f1ed-45f7-b7ab-8fa810d529fa.png\"> <source media=\"(prefers-color-scheme: light)\" srcset=\"https://user-images.githubusercontent.com/25423296/163456779-a8556205-d0a5-45e2-ac17-42d089e3c3f8.png\"> <img alt=\"Shows an illustrated sun in light mode and a moon with stars in dark mode.\" src=\"https://user-images.githubusercontent.com/25423296/163456779-a8556205-d0a5-45e2-ac17-42d089e3c3f8.png\"> </picture> ## How the image looks ## Adding a table You can use Markdown tables to organize information. Here, you'll use a table to introduce yourself by ranking something, such as your most-used programming languages or frameworks, the things you're spending your time learning, or your favorite hobbies. When a table column contains numbers, it's useful to right-align the column by using the syntax --: below the header row. Return to the Edit file tab. Return to the Edit file tab. To introduce yourself, two lines below the </picture> tag, add an ## About me header and a short paragraph about yourself, like the following. ## About me Hi, I'm Mona. You might recognize me as GitHub's mascot. To introduce yourself, two lines below the </picture> tag, add an ## About me header and a short paragraph about yourself, like the following. ## About me ## About me Hi, I'm Mona. You might recognize me as GitHub's mascot. ## About me Hi, I'm Mona. You might recognize me as GitHub's mascot. Two lines below this paragraph, insert a table by copying and pasting the following markup. | Rank | THING-TO-RANK | |-----:|---------------| | 1| | | 2| | | 3| | Two lines below this paragraph, insert a table by copying and pasting the following markup. | Rank | THING-TO-RANK | |-----:|---------------| | 1| | | 2| | | 3| | | Rank | THING-TO-RANK | |-----:|---------------| | 1| | | 2| | | 3| | In the column on the right, replace THING-TO-RANK with \"Languages,\" \"Hobbies,\" or anything else, and fill in the column with your list of things. In the column on the right, replace THING-TO-RANK with \"Languages,\" \"Hobbies,\" or anything else, and fill in the column with your list of things. THING-TO-RANK To check the table has rendered correctly, click the Preview tab. To check the table has rendered correctly, click the Preview tab. For more information, see Organizing information with tables. ## Example of a table ## About me Hi, I'm Mona. You might recognize me as GitHub's mascot. | Rank | Languages | |-----:|-----------| | 1| JavaScript| | 2| Python | | 3| SQL | ## About me Hi, I'm Mona. You might recognize me as GitHub's mascot. | Rank | Languages | |-----:|-----------| | 1| JavaScript| | 2| Python | | 3| SQL | ## How the table looks ## Adding a collapsed section To keep your content tidy, you can use the <details> tag to create an expandable collapsed section. To create a collapsed section for the table you created, wrap your table in <details> tags like in the following example. <details> <summary>My top THINGS-TO-RANK</summary> YOUR TABLE </details> To create a collapsed section for the table you created, wrap your table in <details> tags like in the following example. <details> <summary>My top THINGS-TO-RANK</summary> YOUR TABLE </details> <details> <summary>My top THINGS-TO-RANK</summary> YOUR TABLE </details> Between the <summary> tags, replace THINGS-TO-RANK with whatever you ranked in your table. Between the <summary> tags, replace THINGS-TO-RANK with whatever you ranked in your table. THINGS-TO-RANK Optionally, to make the section display as open by default, add the open attribute to the <details> tag. <details open> Optionally, to make the section display as open by default, add the open attribute to the <details> tag. <details open> <details open> To check the collapsed section has rendered correctly, click the Preview tab. To check the collapsed section has rendered correctly, click the Preview tab. ## Example of a collapsed section <details> <summary>My top languages</summary> | Rank | Languages | |-----:|-----------| | 1| JavaScript| | 2| Python | | 3| SQL | </details> <details> <summary>My top languages</summary> | Rank | Languages | |-----:|-----------| | 1| JavaScript| | 2| Python | | 3| SQL | </details> ## How the collapsed section looks ## Adding a quote Markdown has many other options for formatting your content. Here, you'll add a horizontal rule to divide your page and a blockquote to format your favorite quote. At the bottom of your file, two lines below the </details> tag, add a horizontal rule by typing three or more dashes. --- At the bottom of your file, two lines below the </details> tag, add a horizontal rule by typing three or more dashes. Below the --- line, add a quote by typing markup like the following. > QUOTE Replace QUOTE with a quote of your choice. Alternatively, copy the quote from our example below. Below the --- line, add a quote by typing markup like the following. Replace QUOTE with a quote of your choice. Alternatively, copy the quote from our example below. To check everything has rendered correctly, click the Preview tab. To check everything has rendered correctly, click the Preview tab. ## Example of a quote --- > If we pull together and commit ourselves, then we can push through anything. — Mona the Octocat --- > If we pull together and commit ourselves, then we can push through anything. — Mona the Octocat ## How the quote looks ## Adding a comment You can use HTML comment syntax to add a comment that will be hidden in the output. Here, you'll add a comment to remind yourself to update your README later. Two lines below the ## About me header, insert a comment by using the following markup. <!-- COMMENT --> Replace COMMENT with a \"to-do\" item you remind yourself to do something later (for example, to add more items to the table). Two lines below the ## About me header, insert a comment by using the following markup. ## About me <!-- COMMENT --> <!-- COMMENT --> Replace COMMENT with a \"to-do\" item you remind yourself to do something later (for example, to add more items to the table). To check your comment is hidden in the output, click the Preview tab. To check your comment is hidden in the output, click the Preview tab. ## Example of a comment ## About me <!-- TO DO: add more details about me later --> ## About me <!-- TO DO: add more details about me later --> ## Saving your work When you're happy with your changes, save your profile README by clicking Commit changes. Committing directly to the main branch will make your changes visible to any visitor on your profile. If you want to save your work but aren't ready to make it visible on your profile, you can select Create a new branch for this commit and start a pull request. Continue to learn about advanced formatting features. For example, see Creating diagrams and Creating and highlighting code blocks. Use your new skills as you communicate across GitHub, in issues, pull requests, and discussions. For more information, see Communicating on GitHub.",
    "url": "https://docs.github.com/en/get-started/writing-on-github/getting-started-with-writing-and-formatting-on-github/quickstart-for-writing-on-github",
    "section": "Getting Started",
    "word_count": 1895
  },
  {
    "title": "About mandatory two-factor authentication",
    "content": "## About mandatory two-factor authentication Enable mandatory two-factor authentication to secure your account and maintain access to GitHub.com. ## In this article As of March 2023, GitHub required all users who contribute code on GitHub.com to enable one or more forms of two-factor authentication (2FA). If you were in an eligible group, you would have received a notification email when that group was selected for enrollment, marking the beginning of a 45-day 2FA enrollment period, and you would have seen banners asking you to enroll in 2FA on GitHub.com. If you didn't receive a notification, then you were not part of a group required to enable 2FA, though we strongly recommend it. ## About eligibility for mandatory 2FA Your account is selected for mandatory 2FA if you have taken some action on GitHub that shows you are a contributor. Eligible actions include: Publishing an app or action for others Creating a release for your repository Contributing to specific high-importance repositories, such as the projects tracked by the Open Source Security Foundation Being an administrator or a contributor of a high-importance repository Being an organization owner for an organization containing repositories or other users Being an administrator or a contributor for repositories that published one or more packages Being an enterprise administrator GitHub is continually assessing improvements to our account security features and 2FA requirements, so these criteria may change over time. If your account has an education coupon active, it is exempt from mandatory 2FA. ## About mandatory 2FA for organizations and enterprises Mandatory 2FA is required by GitHub itself to improve security for both individual developers and the broader software development ecosystem. Your administrator may also require 2FA enablement as a requirement to join their organization or enterprise, but those requirements are separate from this program. To find which users have enabled 2FA or are required to do so, see Viewing people in your enterprise or Viewing whether users in your organization have 2FA enabled. Your account's eligibility for mandatory 2FA does not impact the eligibility of other individuals. For example, if you are an organization owner, and your account is eligible for mandatory 2FA, that does not impact the eligibility of other accounts within your organization. GitHub Enterprise Managed Users and on-premise GitHub Enterprise Server users are not required to enable 2FA. Mandatory 2FA enablement only applies to users with a password on GitHub.com. ## About failure to enable mandatory 2FA If you do not enable 2FA within the 45 day setup period, and you allow the 7 day grace period to expire, you will not be able to access GitHub.com until you enable 2FA. If you attempt to access GitHub.com, you will be prompted to enable 2FA. If you fail to enable mandatory 2FA, tokens that belong to your account will continue to function since they are used in critical automation. These tokens include personal access tokens and OAuth tokens issued to applications to act on your behalf. Enabling 2FA will not revoke or change the behavior of tokens issued for your account. However, locked accounts will not be able to authorize new apps or create new PATs until they've enabled 2FA. ## About required 2FA methods We recommend setting up a time-based one-time password (TOTP) app as your primary 2FA method, and adding a passkey or security key as a backup. If you don't have a passkey or security key, the GitHub Mobile app is a good backup option as well. SMS is reliable in most countries, but has security risks that some threat models may not work with. Currently, we don't support passkeys or security keys as primary 2FA methods since they are easy to lose and do not support sync across a wide enough range of devices. As passkeys are more widely adopted and sync support is more prevalent, we will support them as a primary method. About TOTP apps and mandatory 2FA About SAML SSO and mandatory 2FA About email verification and mandatory 2FA We recommend retaining cookies on GitHub.com. If you set your browser to wipe your cookies every day, you'll never have a verified device for account recovery purposes, as the _device_id cookie is used to securely prove you've used that device previously. For more information, see Recovering your account if you lose your 2FA credentials. ## About TOTP apps and mandatory 2FA TOTP apps are the recommended 2FA factor for GitHub. For more information on configuring TOTP apps, see Configuring two-factor authentication. If you do not want to download an app on your mobile device, there are multiple options for standalone TOTP apps that run across platforms. For desktop applications, we recommend KeePassXC, and for browser-based plugins, we recommend 1Password. You can also manually set up any app that generates a code compatible with RFC 6238. For more information on manually setting up a TOTP app, see Configuring two-factor authentication. For more information on RFC 6238, see TOTP: Time-Based One-Time Password Algorithm in the IETF documentation. If you are using FreeOTP for 2FA, you may see a warning about weak cryptographic parameters. GitHub uses an 80 bit secret to ensure compatibility with older versions of Google Authenticator. 80 bits is lower than the 128 bits recommended by the HOTP RFC, but at this time we have no plans to change this and recommend ignoring this message. For more information, see HOTP: An HMAC-Based One-Time Password Algorithm in the IETF documentation. ## About SAML SSO and mandatory 2FA If you have been selected for mandatory 2FA, you must enroll in 2FA on GitHub.com even if your company already requires single sign-on (SSO) with 2FA. While SSO with 2FA is a powerful way to protect organization or enterprise-owned resources, it does not protect user-owned content on GitHub.com unrelated to an organization or enterprise, nor does it protect a user's profile and settings. GitHub only requires you to perform 2FA on the initial authentication and for sensitive actions, so even if you have to perform corporate 2FA every day to access GitHub, you will rarely have to perform 2FA a second time through GitHub. For more information on sensitive actions, see Sudo mode. ## About email verification and mandatory 2FA When you log in to GitHub.com, email verification does not count as 2FA. Your account's email address is used for password resets, which are a form of account recovery. If an attacker has access to your email inbox, they can reset the password for your account and pass the email device verification check, reducing your account's protection to a single factor. We require a second factor to prevent this scenario, so that second factor must be distinct from your email inbox. When you enable 2FA, we will no longer perform email verification on login. ## About service accounts and mandatory 2FA Unattended or shared access accounts in your organization, such as bots and service accounts, that are selected for mandatory two-factor authentication, must enroll in 2FA. Enabling 2FA will not revoke or change the behavior of tokens issued for the service account. GitHub recommends securely storing the TOTP secret of the service account in shared credential storage. For more information, see Managing bots and service accounts with two-factor authentication. ## About your privacy with mandatory 2FA If you have been selected for mandatory 2FA, that does not mean you have to provide GitHub with your phone number. You only have to provide your phone number if you use SMS for 2FA. Instead, we recommend configuring a TOTP app as your primary 2FA method. For more information, see Configuring two-factor authentication. Your region may not be listed in the available SMS options. We monitor SMS delivery success rates on a per region basis, and disallow setup for regions that have poor delivery rates. If you don't see your region on the list, you must set up a TOTP app instead. For more information on supported regions for SMS, see Countries where SMS authentication is supported.",
    "url": "https://docs.github.com/en/authentication/securing-your-account-with-two-factor-authentication-2fa/about-mandatory-two-factor-authentication",
    "section": "Authentication & Security",
    "word_count": 1321
  },
  {
    "title": "Configuring two-factor authentication recovery methods",
    "content": "## Configuring two-factor authentication recovery methods You can set up a variety of recovery methods to access your account if you lose your two-factor authentication credentials. ## In this article In addition to securely storing your two-factor authentication (2FA) recovery codes, we strongly recommend configuring two or more authentication methods to avoid losing access to your account. For more information, see Configuring two-factor authentication. ## Downloading your two-factor authentication recovery codes When you configure two-factor authentication, you'll download and save your 2FA recovery codes. If you lose access to your phone, you can authenticate to GitHub using your recovery codes. You can also download your recovery codes at any point after enabling two-factor authentication. To keep your account secure, don't share or distribute your recovery codes. We recommend saving them with a secure password manager. If you generate new recovery codes or disable and re-enable 2FA, the recovery codes in your security settings automatically update. Reconfiguring your 2FA settings without disabling 2FA will not change your recovery codes. In the upper-right corner of any page on GitHub, click your profile picture, then click Settings. In the upper-right corner of any page on GitHub, click your profile picture, then click Settings. In the \"Access\" section of the sidebar, click Password and authentication. In the \"Access\" section of the sidebar, click Password and authentication. Next to \"Recovery codes,\" click View. Next to \"Recovery codes,\" click View. Save your recovery codes in a safe place. Your recovery codes can help you get back into your account if you lose access. To save your recovery codes on your device, click Download. To save a hard copy of your recovery codes, click Print. To copy your recovery codes for storage in a password manager, click Copy. Save your recovery codes in a safe place. Your recovery codes can help you get back into your account if you lose access. To save your recovery codes on your device, click Download. To save a hard copy of your recovery codes, click Print. To copy your recovery codes for storage in a password manager, click Copy. ## Generating a new set of recovery codes Once you use a recovery code to regain access to your account, it cannot be reused. If you've used all 16 recovery codes, you can generate another list of codes. Generating a new set of recovery codes will invalidate any codes you previously generated. In the upper-right corner of any page on GitHub, click your profile picture, then click Settings. In the upper-right corner of any page on GitHub, click your profile picture, then click Settings. In the \"Access\" section of the sidebar, click Password and authentication. In the \"Access\" section of the sidebar, click Password and authentication. Next to \"Recovery codes,\" click View. Next to \"Recovery codes,\" click View. Under \"Generate new recovery codes\", click Generate new recovery codes. Under \"Generate new recovery codes\", click Generate new recovery codes. ## Configuring backups for your time-based one-time password (TOTP) app Most TOTP apps support backups. If you lose access to your authentication device, you can use your TOTP app backup to access your authentication method and account credentials on a different authentication device, ensuring continued access to your 2FA-enabled account. The process of configuring backups is different for each TOTP app. For some examples from popular TOTP apps, see the following documentation: Google Authenticator Microsoft Authenticator ## Further reading About two-factor authentication Configuring two-factor authentication Accessing GitHub using two-factor authentication Recovering your account if you lose your 2FA credentials",
    "url": "https://docs.github.com/en/authentication/securing-your-account-with-two-factor-authentication-2fa/configuring-two-factor-authentication-recovery-methods",
    "section": "Authentication & Security",
    "word_count": 585
  },
  {
    "title": "About commit signature verification",
    "content": "## About commit signature verification Using GPG, SSH, or S/MIME, you can sign tags and commits locally. These tags or commits are marked as verified on GitHub so other people can be confident that the changes come from a trusted source. ## In this article ## About commit signature verification You can sign commits and tags locally, to give other people confidence about the origin of a change you have made. If a commit or tag has a GPG, SSH, or S/MIME signature that is cryptographically verifiable, GitHub marks the commit or tag \"Verified\" or \"Partially verified.\" For most individual users, GPG or SSH will be the best choice for signing commits. S/MIME signatures are usually required in the context of a larger organization. SSH signatures are the simplest to generate. You can even upload your existing authentication key to GitHub to also use as a signing key. Generating a GPG signing key is more involved than generating an SSH key, but GPG has features that SSH does not. A GPG key can expire or be revoked when no longer used. The GPG signature may include the information about it being expired or revoked. Commits and tags have the following verification statuses, depending on whether you have enabled vigilant mode. By default vigilant mode is not enabled. For information on how to enable vigilant mode, see Displaying verification statuses for all of your commits. Signing commits differs from signing off on a commit. For more information about signing off on commits, see Managing the commit signoff policy for your repository. ## Default statuses ## Persistent commit signature verification Regardless of the signature choice - GPG, SSH, or S/MIME - once a commit signature is verified, it remains verified within its repository's network. See Understanding connections between repositories. When a commit signature is verified upon being pushed to GitHub, a verification record is stored alongside the commit. This record can't be edited and will persist so that signatures remain verified over time, even if signing keys are rotated, revoked, or if contributors leave the organization. The verification record includes a timestamp marking when the verification was completed. This persistent record ensures a consistent verified state, providing a stable history of contributions within the repository. You can view this timestamp by hovering over the \"Verified\" badge on GitHub or by accessing the commit via the REST API, which includes a verified_at field. See REST API endpoints for commits. verified_at Persistent commit signature verification applies to new commits pushed to GitHub. For any commits that predate this feature, a persistent record will be created the next time the commit's signature is verified on GitHub, helping ensure that verified statuses remain stable and reliable across the repository's history. ## Records persist even after revocation and expiration Persistent commit signature verification reflects the verified state of a commit at the time of verification. This means that if a signing key is later revoked, expired, or otherwise altered, previously verified commits retain their verified status based on the record created during the initial verification. GitHub will not re-verify previously signed commits or retroactively adjust their verification status in response to changes in the key's state. Organizations may need to manage key states directly to align with their security policies, especially if frequent key rotation or revocation is planned. ## The verification record is scoped to its repository network The verification record is persistent across the repository network, meaning that if the same commit is pushed again to the same repository or to any of its forks, the existing verification record is reused. This allows GitHub to maintain a consistent verified status across related repositories without re-verifying the commit each time it appears within the network. This persistence reinforces a unified and reliable view of commit authenticity across all instances of the commit within the repository network. ## Signature verification for rebase and merge When using the Rebase and Merge option on a pull request, it's important to note that the commits in the head branch are added to the base branch without commit signature verification. When you use this option, GitHub creates a modified commit, using the data and content of the original commit. This means that GitHub didn't truly create this commit, and can't therefore sign it as a generic system user. GitHub doesn't have access to the committer's private signing keys, so it can't sign the commit on the user's behalf. A workaround for this is to rebase and merge locally, and then push the changes to the pull request's base branch. For more information, see About merge methods on GitHub. ## Statuses with vigilant mode enabled Repository administrators can enforce required commit signing on a branch to block all commits that are not signed and verified. For more information, see About protected branches. You can check the verification status of your signed commits or tags on GitHub and view why your commit signatures might be unverified. For more information, see Checking your commit and tag signature verification status. GitHub will automatically use GPG to sign commits you make using the web interface. Commits signed by GitHub will have a verified status. You can verify the signature locally using the public key available at https://github.com/web-flow.gpg. You can optionally choose to have GitHub GPG sign commits you make in GitHub Codespaces. For more information about enabling GPG verification for your codespaces, see Managing GPG verification for GitHub Codespaces. ## GPG commit signature verification You can use GPG to sign commits with a GPG key that you generate yourself. GitHub uses OpenPGP libraries to confirm that your locally signed commits and tags are cryptographically verifiable against a public key you have added to your account on GitHub.com. To sign commits using GPG and have those commits verified on GitHub, follow these steps: Check for existing GPG keys Generate a new GPG key Add a GPG key to your GitHub account Tell Git about your signing key Sign commits ## SSH commit signature verification You can use SSH to sign commits with an SSH key that you generate yourself. For more information, see the Git reference documentation for user.Signingkey. If you already use an SSH key to authenticate with GitHub, you can also upload that same key again for use as a signing key. There's no limit on the number of signing keys you can add to your account. user.Signingkey GitHub uses ssh_data, an open source Ruby library, to confirm that your locally signed commits and tags are cryptographically verifiable against a public key you have added to your account on GitHub.com. SSH signature verification is available in Git 2.34 or later. To update your version of Git, see the Git website. To sign commits using SSH and have those commits verified on GitHub, follow these steps: Check for existing SSH keys Generate a new SSH key Add a SSH signing key to your GitHub account Tell Git about your signing key Sign commits ## S/MIME commit signature verification You can use S/MIME to sign commits with an X.509 key issued by your organization. GitHub uses the Debian ca-certificates package, the same trust store used by Mozilla browsers, to confirm that your locally signed commits and tags are cryptographically verifiable against a public key in a trusted root certificate. S/MIME signature verification is available in Git 2.19 or later. To update your version of Git, see the Git website. To sign commits using S/MIME and have those commits verified on GitHub, follow these steps: Tell Git about your signing key Sign commits You don't need to upload your public key to GitHub. ## Signature verification for bots Organizations and GitHub Apps that require commit signing can use bots to sign commits. If a commit or tag has a bot signature that is cryptographically verifiable, GitHub marks the commit or tag as verified. Signature verification for bots will only work if the request is verified and authenticated as the GitHub App or bot and contains no custom author information, custom committer information, and no custom signature information, such as Commits API. ## Further reading Signing commits Signing tags Troubleshooting commit signature verification",
    "url": "https://docs.github.com/en/authentication/managing-commit-signature-verification/about-commit-signature-verification",
    "section": "Authentication & Security",
    "word_count": 1354
  },
  {
    "title": "Troubleshooting commit signature verification",
    "content": "## Troubleshooting commit signature verification You may need to troubleshoot unexpected issues that arise when signing commits locally for verification on GitHub. ## Checking your commit and tag signature verification status You can check the verification status of your commit and tag signatures on GitHub. ## Using a verified email address in your GPG key When verifying a signature, GitHub checks that the committer or tagger email address matches an email address from the GPG key's identities and is a verified email address on the user's account. This ensures that the key belongs to you and that you created the commit or tag.",
    "url": "https://docs.github.com/en/authentication/troubleshooting-commit-signature-verification",
    "section": "Authentication & Security",
    "word_count": 103
  },
  {
    "title": "Token expiration and revocation",
    "content": "## Token expiration and revocation Your tokens can expire and can also be revoked by you, applications you have authorized, and GitHub itself. ## In this article When a token has expired or has been revoked, it can no longer be used to authenticate Git and API requests. It is not possible to restore an expired or revoked token, you or the application will need to create a new token. This article explains the possible reasons your GitHub token might be revoked or expire. When a personal access token or OAuth token expires or is revoked, you may see an oauth_authorization.destroy action in your security log. For more information, see Reviewing your security log. oauth_authorization.destroy ## Token revoked after reaching its expiration date When you create a personal access token, we recommend that you set an expiration for your token. Upon reaching your token's expiration date, the token is automatically revoked. For more information, see Managing your personal access tokens. ## Token revoked when pushed to a public repository or public gist If a valid OAuth token, GitHub App token, or personal access token is pushed to a public repository or public gist, the token will be automatically revoked. ## Token expired due to lack of use GitHub will automatically revoke an OAuth token or personal access token when the token hasn't been used in one year. ## Token revoked by the user You can revoke your authorization of a GitHub App or OAuth app from your account settings which will revoke any tokens associated with the app. For more information, see Reviewing and revoking authorization of GitHub Apps and Reviewing your authorized OAuth apps. Once an authorization is revoked, any tokens associated with the authorization will be revoked as well. To reauthorize an application, follow the instructions from the third-party application or website to connect your account on GitHub again. ## Token revoked by a third party To prevent unauthorized access using exposed tokens, GitHub recommends token revocation to ensure that a token can no longer be used to authenticate to GitHub. If you find another user's personal access token leaked on GitHub or elsewhere, you can submit a revocation request through the REST API. See Revocation. If a valid personal access token is submitted to GitHub's credential revocation API, the token will be automatically revoked. This API allows a third party to revoke a token they do not own and helps protect the data associated with this token from unauthorized access, limiting the impact of exposed tokens. To encourage reports and ensure that exposed tokens can be quickly and easily revoked, we do not require authentication for the revocation requests submitted through the API. As a result, GitHub is unable to provide further information about the source of the reported token. ## Token revoked by the OAuth app The owner of an OAuth app can revoke an account's authorization of their app, this will also revoke any tokens associated with the authorization. For more information about revoking authorizations of your OAuth app, see REST API endpoints for OAuth authorizations. OAuth app owners can also revoke individual tokens associated with an authorization. For more information about revoking individual tokens for your OAuth app, see REST API endpoints for OAuth authorizations. ## Token revoked due to excess of tokens for an OAuth app with the same scope There is a limit of ten tokens that are issued per user/application/scope combination, and a rate limit of ten tokens created per hour. If an application creates more than ten tokens for the same user and the same scopes, the oldest tokens with the same user/application/scope combination are revoked. However, hitting the hourly rate limit will not revoke your oldest token. Instead, it will trigger a re-authorization prompt within the browser, asking the user to double check the permissions they're granting your app. This prompt is intended to give a break to any potential infinite loop the app is stuck in, since there's little to no reason for an app to request ten tokens from the user within an hour. ## User token expired due to GitHub App configuration User access tokens created by a GitHub App will expire after eight hours by default, and then must be regenerated using the included refresh token. Owners of GitHub Apps can optionally configure these tokens to never expire instead, but this is not recommended due to the security implications. For more information about configuring your GitHub App's user access tokens, see Activating optional features for GitHub Apps.",
    "url": "https://docs.github.com/en/authentication/keeping-your-account-and-data-secure/token-expiration-and-revocation",
    "section": "Authentication & Security",
    "word_count": 752
  },
  {
    "title": "Deleted or missing SSH keys",
    "content": "## Deleted or missing SSH keys As a security precaution, GitHub automatically deletes SSH keys that haven't been used in a year. GitHub automatically deletes inactive SSH keys to help keep accounts safe, such as after someone leaves a job or loses a computer. You can check if you haven't used an SSH key in a year by reviewing your account's security log. For more information, see Reviewing your security log. After your inactive SSH key is deleted, you must generate a new SSH key and associate it with your account. For more information, see Generating a new SSH key and adding it to the ssh-agent and Adding a new SSH key to your GitHub account.",
    "url": "https://docs.github.com/en/authentication/troubleshooting-ssh/deleted-or-missing-ssh-keys",
    "section": "Authentication & Security",
    "word_count": 116
  },
  {
    "title": "About GitHub's IP addresses",
    "content": "## About GitHub's IP addresses GitHub serves applications from multiple IP address ranges, which are available using the API. You can retrieve a list of the IP addresses for GitHub.com from the meta API endpoint. For more information, see REST API endpoints for meta data. The list of GitHub IP addresses returned by the Meta API is not intended to be an exhaustive list. For example, IP addresses for some GitHub services might not be listed, such as LFS or GitHub Packages. These IP addresses are used by GitHub to serve our content, deliver webhooks, and perform hosted GitHub Actions builds. These ranges are in CIDR notation. You can use an online conversion tool to convert from CIDR notation to IP address ranges, for example: CIDR to IPv4 conversion site. We make changes to our IP addresses from time to time. We do not recommend allowing by IP address, but if you use these IP ranges we strongly encourage regular monitoring of our API. For applications to function, you must allow TCP ports 22, 80, and 443 via our IP ranges for github.com. ## Further reading Troubleshooting connectivity problems Allowing access to GitHub's services from a restricted network",
    "url": "https://docs.github.com/en/authentication/keeping-your-account-and-data-secure/about-githubs-ip-addresses",
    "section": "Authentication & Security",
    "word_count": 198
  },
  {
    "title": "Error: We're doing an SSH key audit",
    "content": "## Error: We're doing an SSH key audit This error means the SSH key you're using to perform a Git operation is unverified. When using an unverified key to perform Git operations, you will be prompted to perform an audit of your SSH keys. ERROR: We're doing an SSH key audit. Reason: unverified due to lack of use Please visit https://github.com/settings/ssh to approve this key so we know it's safe. Fingerprint: ab:08:46:83:ff:f6:c4:f8:a9:4e:68:6b:94:17:f2:46 fatal: could not read from remote repository ERROR: We're doing an SSH key audit. Reason: unverified due to lack of use Please visit https://github.com/settings/ssh to approve this key so we know it's safe. Fingerprint: ab:08:46:83:ff:f6:c4:f8:a9:4e:68:6b:94:17:f2:46 fatal: could not read from remote repository ## Solving the issue To fix this, you need to review your SSH keys and either reject or approve the unverified key. Clicking the URL link in the error message brings you to the SSH Settings page, where the unverified SSH key is highlighted in the SSH key list.",
    "url": "https://docs.github.com/en/authentication/troubleshooting-ssh/error-were-doing-an-ssh-key-audit",
    "section": "Authentication & Security",
    "word_count": 163
  },
  {
    "title": "Signing commits",
    "content": "## Signing commits You can sign commits locally using GPG, SSH, or S/MIME. GitHub Desktop only supports commit signing if your Git client is configured to sign commits by default. To configure your Git client to sign commits by default for a local repository, in Git versions 2.0.0 and above, run git config commit.gpgsign true. To sign all commits by default in any local repository on your computer, run git config --global commit.gpgsign true. git config commit.gpgsign true git config --global commit.gpgsign true To store your GPG key passphrase so you don't have to enter it every time you sign a commit, we recommend using the following tools: For Mac users, the GPG Suite allows you to store your GPG key passphrase in the macOS Keychain. For Windows users, the Gpg4win integrates with other Windows tools. You can also manually configure gpg-agent to save your GPG key passphrase, but this doesn't integrate with macOS Keychain like ssh-agent and requires more setup. If you have multiple keys or are attempting to sign commits or tags with a key that doesn't match your committer identity, you should tell Git about your signing key. When committing changes in your local branch, add the -S flag to the git commit command: $ git commit -S -m \"YOUR_COMMIT_MESSAGE\" # Creates a signed commit When committing changes in your local branch, add the -S flag to the git commit command: $ git commit -S -m \"YOUR_COMMIT_MESSAGE\" # Creates a signed commit $ git commit -S -m \"YOUR_COMMIT_MESSAGE\" # Creates a signed commit If you're using GPG, after you create your commit, provide the passphrase you set up when you generated your GPG key. If you're using GPG, after you create your commit, provide the passphrase you set up when you generated your GPG key. When you've finished creating commits locally, push them to your remote repository on GitHub: $ git push # Pushes your local commits to the remote repository When you've finished creating commits locally, push them to your remote repository on GitHub: $ git push # Pushes your local commits to the remote repository $ git push # Pushes your local commits to the remote repository On GitHub, navigate to your pull request. On GitHub, navigate to your pull request. On the pull request, click Commits. On the pull request, click Commits. To view more detailed information about the verified signature, click Verified. To view more detailed information about the verified signature, click Verified. ## Further reading Telling Git about your signing key Signing tags Managing GPG verification for GitHub Codespaces",
    "url": "https://docs.github.com/en/authentication/managing-commit-signature-verification/signing-commits",
    "section": "Authentication & Security",
    "word_count": 427
  },
  {
    "title": "About authentication to GitHub",
    "content": "## About authentication to GitHub You can securely access your account's resources by authenticating to GitHub, using different credentials depending on where you authenticate. ## In this article ## About authentication to GitHub To keep your account secure, you must authenticate before you can access certain resources on GitHub. When you authenticate to GitHub, you supply or confirm credentials that are unique to you to prove that you are exactly who you declare to be. You can access your resources in GitHub in a variety of ways: in the browser, via GitHub Desktop or another desktop application, with the API, or via the command line. Each way of accessing GitHub supports different modes of authentication. Username and password (or social login) with two-factor authentication, or a passkey (GitHub Free, and GitHub Enterprise Cloud only) Personal access token ## Authenticating in your browser If you're a member of an enterprise with managed users, you will authenticate to GitHub in your browser using your IdP. For more information, see About Enterprise Managed Users in the GitHub Enterprise Cloud documentation. If you're not a member of an enterprise with managed users, you will authenticate using your GitHub username and password, or a passkey. You may also use two-factor authentication and SAML single sign-on, which can be required by organization and enterprise owners. As of March 2023, GitHub required all users who contribute code on GitHub.com to enable one or more forms of two-factor authentication (2FA). If you were in an eligible group, you would have received a notification email when that group was selected for enrollment, marking the beginning of a 45-day 2FA enrollment period, and you would have seen banners asking you to enroll in 2FA on GitHub.com. If you didn't receive a notification, then you were not part of a group required to enable 2FA, though we strongly recommend it. For more information about the 2FA enrollment rollout, see this blog post. If you need to use multiple accounts on GitHub.com, such as a personal account and a service account, you can quickly switch between your accounts without always needing to reauthenticate each time. For more information, see Switching between accounts. Username and password only You'll create a password when you create your account on GitHub. We recommend that you use a password manager to generate a random and unique password. For more information, see Creating a strong password. If you have not enabled 2FA, GitHub may ask for additional verification when you first sign in from a new or unrecognized device, such as a new browser profile, a browser where the cookies have been deleted, or a new computer. For more information, see Verifying new devices when signing in. Username and password only You'll create a password when you create your account on GitHub. We recommend that you use a password manager to generate a random and unique password. For more information, see Creating a strong password. If you have not enabled 2FA, GitHub may ask for additional verification when you first sign in from a new or unrecognized device, such as a new browser profile, a browser where the cookies have been deleted, or a new computer. For more information, see Verifying new devices when signing in. Social login You'll authenticate with one of the supported social login providers (currently only Google is supported) when you create your account on GitHub. We recommend that you also configure 2FA and add a passkey or a password as an additional account recovery mechanism. If you have an existing account created with a password, you can add your social login email to the account. This allows you to use your social login identity as a first-factor (password) replacement when you sign in to GitHub. You can unlink your social login identities from your GitHub email settings page. For more information, see Unlinking your email address from a locked account Social login You'll authenticate with one of the supported social login providers (currently only Google is supported) when you create your account on GitHub. We recommend that you also configure 2FA and add a passkey or a password as an additional account recovery mechanism. If you have an existing account created with a password, you can add your social login email to the account. This allows you to use your social login identity as a first-factor (password) replacement when you sign in to GitHub. You can unlink your social login identities from your GitHub email settings page. For more information, see Unlinking your email address from a locked account Two-factor authentication (2FA) (recommended) If you enable two-factor authentication (2FA), after you sign in with social login or your username and password, you'll be prompted to enter a code from a time-based one-time password (TOTP) application on your mobile device or sent as a text message (SMS). After you configure 2FA, your account enters a check up period for 28 days. You can leave the check up period by successfully performing 2FA within those 28 days. If you don't perform 2FA in that timespan, you'll then be asked to perform 2FA inside one of your existing GitHub sessions. If you cannot perform 2FA to pass the 28th day checkup, you will be provided a shortcut that lets you reconfigure your 2FA settings. You must reconfigure your settings before you can access the rest of GitHub. For more information, see Accessing GitHub using two-factor authentication and Configuring two-factor authentication. In addition to authentication with a TOTP application or a text message, you can optionally add an alternative method of authentication with GitHub Mobile or a security key using WebAuthn. See Configuring two-factor authentication using GitHub Mobile or Configuring two-factor authentication using a security key. Note If you cannot use any recovery methods, you have permanently lost access to your account. However, you can unlink an email address tied to the locked account. The unlinked email address can then be linked to a new or existing account. For more information, see Unlinking your email address from a locked account. Two-factor authentication (2FA) (recommended) If you enable two-factor authentication (2FA), after you sign in with social login or your username and password, you'll be prompted to enter a code from a time-based one-time password (TOTP) application on your mobile device or sent as a text message (SMS). If you enable two-factor authentication (2FA), after you sign in with social login or your username and password, you'll be prompted to enter a code from a time-based one-time password (TOTP) application on your mobile device or sent as a text message (SMS). After you configure 2FA, your account enters a check up period for 28 days. You can leave the check up period by successfully performing 2FA within those 28 days. If you don't perform 2FA in that timespan, you'll then be asked to perform 2FA inside one of your existing GitHub sessions. After you configure 2FA, your account enters a check up period for 28 days. You can leave the check up period by successfully performing 2FA within those 28 days. If you don't perform 2FA in that timespan, you'll then be asked to perform 2FA inside one of your existing GitHub sessions. If you cannot perform 2FA to pass the 28th day checkup, you will be provided a shortcut that lets you reconfigure your 2FA settings. You must reconfigure your settings before you can access the rest of GitHub. For more information, see Accessing GitHub using two-factor authentication and Configuring two-factor authentication. If you cannot perform 2FA to pass the 28th day checkup, you will be provided a shortcut that lets you reconfigure your 2FA settings. You must reconfigure your settings before you can access the rest of GitHub. For more information, see Accessing GitHub using two-factor authentication and Configuring two-factor authentication. In addition to authentication with a TOTP application or a text message, you can optionally add an alternative method of authentication with GitHub Mobile or a security key using WebAuthn. See Configuring two-factor authentication using GitHub Mobile or Configuring two-factor authentication using a security key. Note If you cannot use any recovery methods, you have permanently lost access to your account. However, you can unlink an email address tied to the locked account. The unlinked email address can then be linked to a new or existing account. For more information, see Unlinking your email address from a locked account. In addition to authentication with a TOTP application or a text message, you can optionally add an alternative method of authentication with GitHub Mobile or a security key using WebAuthn. See Configuring two-factor authentication using GitHub Mobile or Configuring two-factor authentication using a security key. If you cannot use any recovery methods, you have permanently lost access to your account. However, you can unlink an email address tied to the locked account. The unlinked email address can then be linked to a new or existing account. For more information, see Unlinking your email address from a locked account. Passkey You can add a passkey to your account to enable a secure, passwordless login. Passkeys satisfy both password and 2FA requirements, so you can complete your sign in with a single step. See About passkeys. You can add a passkey to your account to enable a secure, passwordless login. Passkeys satisfy both password and 2FA requirements, so you can complete your sign in with a single step. See About passkeys. SAML single sign-on Before you can access resources owned by an organization or enterprise account that uses SAML single sign-on, you may need to also authenticate through an IdP. For more information, see About authentication with single sign-on in the GitHub Enterprise Cloud documentation. SAML single sign-on Before you can access resources owned by an organization or enterprise account that uses SAML single sign-on, you may need to also authenticate through an IdP. For more information, see About authentication with single sign-on in the GitHub Enterprise Cloud documentation. ## Session cookies GitHub uses cookies to provide services and increase security. You can review details about GitHub's cookies in GitHub Cookies. The gist.github.com and github.com domains use separate cookies. GitHub typically marks a user session for deletion after two weeks of inactivity. GitHub does not immediately delete a session when you sign out. Periodically, GitHub automatically deletes expired sessions. ## Authenticating with GitHub Desktop You can authenticate with GitHub Desktop using your browser. For more information, see Authenticating to GitHub in GitHub Desktop. ## Authenticating with the API You can authenticate with the API in different ways. For more information, see Authenticating to the REST API. ## Authenticating to the API with a personal access token If you want to use the GitHub REST API for personal use, you can create a personal access token. If possible, GitHub recommends that you use a fine-grained personal access token instead of a personal access token (classic). For more information about creating a personal access token, see Managing your personal access tokens. ## Authenticating to the API with an app If you want to use the API on behalf of an organization or another user, GitHub recommends that you use a GitHub App. For more information, see About authentication with a GitHub App. You can also create an OAuth token with an OAuth app to access the REST API. However, GitHub recommends that you use a GitHub App instead. GitHub Apps allow more control over the access and permission that the app has. ## Authenticating to the API in a GitHub Actions workflow If you want to use the API in a GitHub Actions workflow, GitHub recommends that you authenticate with the built-in GITHUB_TOKEN instead of creating a token. You can grant permissions to the GITHUB_TOKEN with the permissions key. GITHUB_TOKEN GITHUB_TOKEN permissions Note that GITHUB_TOKEN can only access resources within the repository that contains the workflow. If you need to make changes to resources outside of the workflow repository, you will need to use a personal access token or GitHub App. GITHUB_TOKEN For more information, see Use GITHUB_TOKEN for authentication in workflows. ## Authenticating with the command line You can access repositories on GitHub from the command line in two ways, HTTPS and SSH, and both have a different way of authenticating. The method of authenticating is determined based on whether you choose an HTTPS or SSH remote URL when you clone the repository. For more information about which way to access, see About remote repositories. You can work with all repositories on GitHub over HTTPS, even if you are behind a firewall or proxy. If you authenticate with GitHub CLI, you can either authenticate with a personal access token or via the web browser. For more information about authenticating with GitHub CLI, see gh auth login. gh auth login If you authenticate without GitHub CLI, you must authenticate with a personal access token. When Git prompts you for your password, enter your personal access token. Alternatively, you can use a credential helper like Git Credential Manager. Password-based authentication for Git has been removed in favor of more secure authentication methods. For more information, see Managing your personal access tokens. Every time you use Git to authenticate with GitHub, you'll be prompted to enter your credentials, unless you cache them with a credential helper. You can work with all repositories on GitHub over SSH, although firewalls and proxies might refuse to allow SSH connections. If you authenticate with GitHub CLI, the CLI will find SSH public keys on your machine and will prompt you to select one for upload. If GitHub CLI does not find a SSH public key for upload, it can generate a new SSH public/private keypair and upload the public key to your account on GitHub.com. Then, you can either authenticate with a personal access token or via the web browser. For more information about authenticating with GitHub CLI, see gh auth login. gh auth login If you authenticate without GitHub CLI, you will need to generate an SSH public/private keypair on your local machine and add the public key to your account on GitHub.com. For more information, see Generating a new SSH key and adding it to the ssh-agent. Every time you use Git to authenticate with GitHub, you'll be prompted to enter your SSH key passphrase, unless you've stored the key. ## Authorizing for SAML single sign-on To use a personal access token or SSH key to access resources owned by an organization that uses SAML single sign-on, you must also authorize the personal token or SSH key. For more information, see Authorizing a personal access token for use with single sign-on or Authorizing an SSH key for use with single sign-on in the GitHub Enterprise Cloud documentation. ## GitHub's token formats GitHub issues tokens that begin with a prefix to indicate the token's type. github_pat_",
    "url": "https://docs.github.com/en/authentication/keeping-your-account-and-data-secure/about-authentication-to-github",
    "section": "Authentication & Security",
    "word_count": 2461
  },
  {
    "title": "Preventing unauthorized access",
    "content": "## Preventing unauthorized access You may be alerted to a security incident in the media, such as the discovery of the Heartbleed bug, or your computer could be stolen while you're signed in to GitHub. In such cases, changing your password prevents any unintended future access to your account and projects. GitHub requires a password to perform sensitive actions, such as adding new SSH keys, authorizing applications, or modifying team members. After changing your password, you should perform these actions to make sure that your account is secure: Enable two-factor authentication on your account so that access requires more than just a password. For more information, see About two-factor authentication. Enable two-factor authentication on your account so that access requires more than just a password. For more information, see About two-factor authentication. Add a passkey to your account to enable a secure, passwordless login. Passkeys are phishing-resistant, and they don't require memorization or active management. See About passkeys. Add a passkey to your account to enable a secure, passwordless login. Passkeys are phishing-resistant, and they don't require memorization or active management. See About passkeys. Review your SSH keys, deploy keys, and authorized OAuth apps and GitHub Apps and revoke unauthorized or unfamiliar access in your SSH and Applications settings. For more information, see Reviewing your SSH keys, Reviewing your deploy keys, Reviewing your authorized OAuth apps, and Reviewing and revoking authorization of GitHub Apps. Review your SSH keys, deploy keys, and authorized OAuth apps and GitHub Apps and revoke unauthorized or unfamiliar access in your SSH and Applications settings. For more information, see Reviewing your SSH keys, Reviewing your deploy keys, Reviewing your authorized OAuth apps, and Reviewing and revoking authorization of GitHub Apps. Verify all your email addresses. If an attacker added their email address to your account, it could allow them to force an unintended password reset. For more information, see Verifying your email address. Verify all your email addresses. If an attacker added their email address to your account, it could allow them to force an unintended password reset. For more information, see Verifying your email address. Review your account's security log. This provides an overview on various configurations made to your repositories. For example, you can ensure that no private repositories were turned public, or that no repositories were transferred. For more information, see Reviewing your security log. Review your account's security log. This provides an overview on various configurations made to your repositories. For example, you can ensure that no private repositories were turned public, or that no repositories were transferred. For more information, see Reviewing your security log. Review the webhooks on your repositories. Webhooks could allow an attacker to intercept pushes made to your repository. For more information, see About webhooks. Review the webhooks on your repositories. Webhooks could allow an attacker to intercept pushes made to your repository. For more information, see About webhooks. Make sure that no new deploy keys were created. This could enable outside servers access to your projects. For more information, see Managing deploy keys. Make sure that no new deploy keys were created. This could enable outside servers access to your projects. For more information, see Managing deploy keys. Review recent commits made to your repositories. Review recent commits made to your repositories. Review the list of collaborators for each repository. Review the list of collaborators for each repository.",
    "url": "https://docs.github.com/en/authentication/keeping-your-account-and-data-secure/preventing-unauthorized-access",
    "section": "Authentication & Security",
    "word_count": 562
  },
  {
    "title": "Authenticating with single sign-on",
    "content": "## Authenticating with single sign-on You can authenticate to GitHub with single sign-on (SSO) and view your active sessions. ## Authenticating with Enterprise Managed Users Learn how to authenticate to access an enterprise with managed users on GitHub. ## About authentication with single sign-on You can access an organization that uses single sign-on (SSO) by authenticating through an identity provider (IdP). ## Authorizing an SSH key for use with single sign-on To use an SSH key with an organization that uses single sign-on (SSO), you must first authorize the key. ## Authorizing a personal access token for use with single sign-on To use a personal access token (classic) with an organization that uses single sign-on (SSO), you must first authorize the token. ## Viewing and managing your active SSO sessions You can view and revoke your active SSO sessions in your settings.",
    "url": "https://docs.github.com/en/authentication/authenticating-with-single-sign-on",
    "section": "Authentication & Security",
    "word_count": 142
  },
  {
    "title": "Verifying new devices when signing in",
    "content": "## Verifying new devices when signing in When you sign in for the first time from a new or unrecognized device without two-factor authentication enabled, GitHub may ask for additional verification to confirm that it is you. ## In this article ## About device verification To keep your account secure when two-factor authentication (2FA) is not enabled, GitHub may ask you to verify your sign-in attempt when you access your account from an unrecognized device for the first time. This is called device verification. An unrecognized device requiring verification may include a new computer or phone, a new browser, or new browser profile. You will only need to verify a new device once. If you clear your cookies, or use a different browser on the same device, GitHub may ask you to verify your device again. GitHub will not ask you to perform device verification when you have 2FA enabled, or when you sign in using a passkey. See Signing in with a passkey. ## Verifying your sign-in attempt Sign in to GitHub, using your username and password. If you are signing in from an unrecognized device, GitHub may ask to you pass a \"Device verification\" prompt. The verification code is sent to all primary and backup email addresses associated with your account. The code is valid for one hour. If you have the GitHub Mobile application installed, GitHub sends a verification request to your mobile device, instead of sending an email. Enter the code displayed in your browser into the GitHub Mobile app to verify your sign-in. You can request an email code if your mobile device is unavailable. If you have the GitHub Mobile application installed, GitHub sends a verification request to your mobile device, instead of sending an email. Enter the code displayed in your browser into the GitHub Mobile app to verify your sign-in. You can request an email code if your mobile device is unavailable. Enter the verification code into your browser to verify your sign-in. ## Troubleshooting device verification If you do not receive the verification code, make sure that you are checking the right email address. We only send the verification code to the primary and backup email addresses associated with your account. GitHub will provide you with a hint of the email(s) that the verification code was sent to. If you are certain that you are accessing the correct address, ensure your email account can receive emails from GitHub, or try waiting a few minutes in case there are temporary deliverability delays. If you cannot provide the verification code because you don’t have access to your email address, you will not be able to verify your new device. You can access your GitHub account by using a device you’ve used before and, from there, you should add an email address that you can access to your account. See Verifying your email address. If you cannot provide the verification code and do not have another active session on a device you’ve used before, you may be able to contact the provider of your email address account to determine your account recovery options. If your email address is completely inaccessible, you can create a new GitHub account with a different username and email address. See Creating an account on GitHub. ## Receiving an unexpected device verification email If you receive a verification code from GitHub that you did not request, your GitHub password may have been compromised. You should immediately change your password and take steps to make sure that your account is secure. See Preventing unauthorized access. ## Disabling device verification You can disable the requirement to verify new devices via email by enabling 2FA. It is not possible to opt-out of device verification entirely without enabling 2FA. See Configuring two-factor authentication. You can sign in using a passkey to skip the device verification prompt. See Signing in with a passkey.",
    "url": "https://docs.github.com/en/authentication/keeping-your-account-and-data-secure/verifying-new-devices-when-signing-in",
    "section": "Authentication & Security",
    "word_count": 648
  },
  {
    "title": "Error: Unknown key type",
    "content": "## Error: Unknown key type This error means that the SSH key type you used was unrecognized or is unsupported by your SSH client. ## Platform navigation ## In this article ## About the unknown key type error unknown key type When you generate a new SSH key, you may receive an unknown key type error if your SSH client does not support the key type that you specify. unknown key type ## Prerequisites You must have Homebrew installed. For more information, see the installation guide in the Homebrew documentation. ## Solving the issue If you install OpenSSH, your computer will not be able to retrieve passphrases that are stored in the Apple keychain. You will need to enter your passphrase or interact with your hardware security key every time you authenticate with SSH to GitHub or another web service. If you remove OpenSSH, the passphrases that are stored in your keychain will once again be retrievable. You can remove OpenSSH by entering the command brew uninstall openssh in Terminal. brew uninstall openssh Open Terminal. Enter the command brew install openssh. brew install openssh Quit and relaunch Terminal. Try the procedure for generating a new SSH key again. For more information, see Generating a new SSH key and adding it to the ssh-agent.",
    "url": "https://docs.github.com/en/authentication/troubleshooting-ssh/error-unknown-key-type",
    "section": "Authentication & Security",
    "word_count": 213
  },
  {
    "title": "Recovering your SSH key passphrase",
    "content": "## Recovering your SSH key passphrase If you've lost your SSH key passphrase, depending on the operating system you use, you may either recover it or you may need to generate a new SSH key passphrase. ## Platform navigation If you configured your SSH passphrase with the macOS keychain, you may be able to recover it. In Finder, search for the Keychain Access app. In Keychain Access, search for SSH. Double click on the entry for your SSH key to open a new dialog box. In the lower-left corner, select Show password. You'll be prompted for your administrative password. Type it into the \"Keychain Access\" dialog box. Your password will be revealed. If you lose your SSH key passphrase, there's no way to recover it. You'll need to generate a brand new SSH keypair or switch to HTTPS cloning so you can use a personal access token instead. If you lose your SSH key passphrase, there's no way to recover it. You'll need to generate a brand new SSH keypair or switch to HTTPS cloning so you can use a personal access token instead.",
    "url": "https://docs.github.com/en/authentication/troubleshooting-ssh/recovering-your-ssh-key-passphrase",
    "section": "Authentication & Security",
    "word_count": 184
  },
  {
    "title": "Transferring a repository",
    "content": "## Transferring a repository You can transfer repositories to other users or organization accounts. ## In this article ## About repository transfers When you transfer a repository to a new owner, they can immediately administer the repository's contents, issues, pull requests, releases, projects, and settings. You can also change the repository name while transferring a repository. See Renaming a repository. Prerequisites for repository transfers: When you transfer a repository that you own to another personal account, the new owner will receive a confirmation email. The confirmation email includes instructions for accepting the transfer. If the new owner doesn't accept the transfer within one day, the invitation will expire. To transfer a repository you must have administrator access to the repository. Repositories on GitHub.com can only be transferred to other owners on GitHub.com. To transfer a repository that you own to an organization, you must have permission to create a repository in the target organization. The target account must not have a repository with the same name, or a fork in the same network. The original owner of the repository is added as a collaborator on the transferred repository. Other collaborators to the transferred repository remain intact. Single repositories forked from a private upstream network cannot be transferred. If you transfer a private repository to a GitHub Free user or organization account, the repository will lose access to features like protected branches and GitHub Pages. For more information, see GitHub’s plans. If the transferred repository contains an action listed on GitHub Marketplace, or had more than 100 clones or more than 100 uses of GitHub Actions in the week prior to the transfer, GitHub permanently retires the owner name and repository name combination (OWNER/REPOSITORY-NAME) when you transfer the repository. If you try to create a repository using a retired owner name and repository name combination, you will see the error: \"The repository REPOSITORY_NAME has been retired and cannot be reused.\" OWNER/REPOSITORY-NAME REPOSITORY_NAME ## What's transferred with a repository? When you transfer a repository, its issues, pull requests, wiki, stars, and watchers are also transferred. If the transferred repository contains webhooks, services, secrets, or deploy keys, they will remain associated after the transfer is complete. Git information about commits, including contributions, is preserved. In addition: If the transferred repository is a fork, then it remains associated with the upstream repository. If the transferred repository is a fork, then it remains associated with the upstream repository. If the transferred repository has any forks, then those forks will remain associated with the repository after the transfer is complete. If the transferred repository has any forks, then those forks will remain associated with the repository after the transfer is complete. If the transferred repository uses Git Large File Storage, all Git LFS objects are automatically moved. This transfer occurs in the background, so if you have a large number of Git LFS objects or if the Git LFS objects themselves are large, it may take some time for the transfer to occur. If the transferred repository uses Git Large File Storage, all Git LFS objects are automatically moved. This transfer occurs in the background, so if you have a large number of Git LFS objects or if the Git LFS objects themselves are large, it may take some time for the transfer to occur. When a repository is transferred between two personal accounts, issue assignments are left intact. When you transfer a repository from a personal account to an organization, issues assigned to members in the organization remain intact, and all other issue assignees are cleared. Only owners in the organization are allowed to create new issue assignments. When you transfer a repository from an organization to a personal account, only issues assigned to the repository's owner are kept, and all other issue assignees are removed. When a repository is transferred between two personal accounts, issue assignments are left intact. When you transfer a repository from a personal account to an organization, issues assigned to members in the organization remain intact, and all other issue assignees are cleared. Only owners in the organization are allowed to create new issue assignments. When you transfer a repository from an organization to a personal account, only issues assigned to the repository's owner are kept, and all other issue assignees are removed. When you transfer a repository from an organization to another organization, issue types on issues are left intact if the new organization has a matching issue type, and all other issue types are removed from issues. When you transfer a repository from an organization to another organization, issue types on issues are left intact if the new organization has a matching issue type, and all other issue types are removed from issues. When you transfer a repository from an organization to a personal account, all issue types are removed from issues. When you transfer a repository from an organization to a personal account, all issue types are removed from issues. If the transferred repository contains a GitHub Pages site, then links to the Git repository on the Web and through Git activity are redirected. However, we don't redirect GitHub Pages associated with the repository. If the transferred repository contains a GitHub Pages site, then links to the Git repository on the Web and through Git activity are redirected. However, we don't redirect GitHub Pages associated with the repository. All links to the previous repository location are automatically redirected to the new location. When you use git clone, git fetch, or git push on a transferred repository, these commands will redirect to the new repository location or URL. However, to avoid confusion, we strongly recommend updating any existing local clones to point to the new repository URL. You can do this by using git remote on the command line: git remote set-url origin NEW_URL Warning If you create a new repository or fork at the previous repository location, the redirects to the transferred repository will be permanently deleted. All links to the previous repository location are automatically redirected to the new location. When you use git clone, git fetch, or git push on a transferred repository, these commands will redirect to the new repository location or URL. However, to avoid confusion, we strongly recommend updating any existing local clones to point to the new repository URL. You can do this by using git remote on the command line: git remote set-url origin NEW_URL git remote set-url origin NEW_URL If you create a new repository or fork at the previous repository location, the redirects to the transferred repository will be permanently deleted. When you transfer a repository from an organization to a personal account, the repository's read-only collaborators will not be transferred. This is because collaborators can't have read-only access to repositories owned by a personal account. For more information about repository permission levels, see Permission levels for a personal account repository and Repository roles for an organization. When you transfer a repository from an organization to a personal account, the repository's read-only collaborators will not be transferred. This is because collaborators can't have read-only access to repositories owned by a personal account. For more information about repository permission levels, see Permission levels for a personal account repository and Repository roles for an organization. Sponsors who have access to the repository through a sponsorship tier may be affected. See Managing your sponsorship tiers. Sponsors who have access to the repository through a sponsorship tier may be affected. See Managing your sponsorship tiers. Packages associated with the repository may be transferred, or may lose their link to the repository, depending on the registry they belong to. See About permissions for GitHub Packages. Packages associated with the repository may be transferred, or may lose their link to the repository, depending on the registry they belong to. See About permissions for GitHub Packages. See Managing remote repositories. ## Repository transfers and organizations To transfer repositories to an organization, you must have permission to create repositories in the receiving organization, and to transfer repositories out of the origin organization. An organization or enterprise owner may have set a policy that prevents certain users from doing these things. Once a repository is transferred to an organization, the organization's default repository permission settings and default membership privileges will apply to the transferred repository. ## Transferring a repository owned by your personal account You can transfer your repository to any personal account that accepts your repository transfer. When a repository is transferred between two personal accounts, the original repository owner and collaborators are automatically added as collaborators to the new repository. If you published a GitHub Pages site in a private repository and added a custom domain, before transferring the repository, you may want to remove or update your DNS records to avoid the risk of a domain takeover. See Managing a custom domain for your GitHub Pages site. On GitHub, navigate to the main page of the repository. On GitHub, navigate to the main page of the repository. Under your repository name, click Settings. If you cannot see the \"Settings\" tab, select the dropdown menu, then click Settings. Under your repository name, click Settings. If you cannot see the \"Settings\" tab, select the dropdown menu, then click Settings. At the bottom of the page, in the \"Danger Zone\" section, click Transfer. At the bottom of the page, in the \"Danger Zone\" section, click Transfer. Read the information about transferring a repository, then, under \"New owner\", choose how to specify the new owner. To choose one of your organizations, select Select one of my organizations. Select the dropdown menu and click an organization. Optionally, in the \"Repository name\" field, type a new name for the repository. Note You must be an owner of the target organization to rename the repository. To specify an organization or username, select Specify an organization or username, then type the organization name or the new owner's username. Read the information about transferring a repository, then, under \"New owner\", choose how to specify the new owner. To choose one of your organizations, select Select one of my organizations. Select the dropdown menu and click an organization. Optionally, in the \"Repository name\" field, type a new name for the repository. Note You must be an owner of the target organization to rename the repository. To choose one of your organizations, select Select one of my organizations. Select the dropdown menu and click an organization. Select the dropdown menu and click an organization. Optionally, in the \"Repository name\" field, type a new name for the repository. Note You must be an owner of the target organization to rename the repository. Optionally, in the \"Repository name\" field, type a new name for the repository. You must be an owner of the target organization to rename the repository. To specify an organization or username, select Specify an organization or username, then type the organization name or the new owner's username. To specify an organization or username, select Specify an organization or username, then type the organization name or the new owner's username. Read the warnings about potential loss of features depending on the new owner's GitHub subscription. Read the warnings about potential loss of features depending on the new owner's GitHub subscription. Following Type REPOSITORY NAME to confirm, type the name of the repository you'd like to transfer, then click I understand, transfer this repository. Following Type REPOSITORY NAME to confirm, type the name of the repository you'd like to transfer, then click I understand, transfer this repository. ## Transferring a repository owned by your organization If you have owner permissions in an organization or admin permissions to one of its repositories, you can transfer a repository owned by your organization to your personal account or to another organization. Sign into your personal account that has admin or owner permissions in the organization that owns the repository. Sign into your personal account that has admin or owner permissions in the organization that owns the repository. On GitHub, navigate to the main page of the repository. On GitHub, navigate to the main page of the repository. Under your repository name, click Settings. If you cannot see the \"Settings\" tab, select the dropdown menu, then click Settings. Under your repository name, click Settings. If you cannot see the \"Settings\" tab, select the dropdown menu, then click Settings. At the bottom of the page, in the \"Danger Zone\" section, click Transfer. At the bottom of the page, in the \"Danger Zone\" section, click Transfer. Read the information about transferring a repository, then, under \"New owner\", choose how to specify the new owner. To choose one of your organizations, select Select one of my organizations. Select the dropdown menu and click an organization. Optionally, in the \"Repository name\" field, type a new name for the repository. Note You must be an owner of the target organization to rename the repository. To specify an organization or username, select Specify an organization or username, then type the organization name or the new owner's username. Read the information about transferring a repository, then, under \"New owner\", choose how to specify the new owner. To choose one of your organizations, select Select one of my organizations. Select the dropdown menu and click an organization. Optionally, in the \"Repository name\" field, type a new name for the repository. Note You must be an owner of the target organization to rename the repository. To choose one of your organizations, select Select one of my organizations. Select the dropdown menu and click an organization. Select the dropdown menu and click an organization. Optionally, in the \"Repository name\" field, type a new name for the repository. Note You must be an owner of the target organization to rename the repository. Optionally, in the \"Repository name\" field, type a new name for the repository. You must be an owner of the target organization to rename the repository. To specify an organization or username, select Specify an organization or username, then type the organization name or the new owner's username. To specify an organization or username, select Specify an organization or username, then type the organization name or the new owner's username. Read the warnings about potential loss of features depending on the new owner's GitHub subscription. Read the warnings about potential loss of features depending on the new owner's GitHub subscription. Following Type REPOSITORY NAME to confirm, type the name of the repository you'd like to transfer, then click I understand, transfer this repository. Following Type REPOSITORY NAME to confirm, type the name of the repository you'd like to transfer, then click I understand, transfer this repository.",
    "url": "https://docs.github.com/en/repositories/creating-and-managing-repositories/transferring-a-repository",
    "section": "Repository Management",
    "word_count": 2428
  },
  {
    "title": "Managing files",
    "content": "## Managing files You can create, edit, move, and delete files in a repository, directly on GitHub or on the command line. ## Creating new files You can create new files directly on GitHub in any repository you have write access to. ## Adding a file to a repository You can upload and commit an existing file to a repository on GitHub or by using the command line. ## Moving a file to a new location You can move a file to a different directory on GitHub or by using the command line. ## Editing files You can edit files directly on GitHub in any of your repositories using the file editor. ## Renaming a file You can rename any file in your repository directly in GitHub or by using the command line. ## Deleting files in a repository You can delete an individual file or an entire directory in your repository on GitHub. ## Customizing how changed files appear on GitHub To keep certain files from displaying in diffs by default, or counting toward the repository language, you can mark them with the linguist-generated attribute in a .gitattributes file. linguist-generated",
    "url": "https://docs.github.com/en/repositories/working-with-files/managing-files",
    "section": "Repository Management",
    "word_count": 191
  },
  {
    "title": "Managing repository settings",
    "content": "## Managing repository settings You can choose the way your repository functions by managing repository settings. ## Setting repository visibility You can choose who can view your repository. ## Managing teams and people with access to your repository You can see everyone who has access to your repository and adjust permissions. ## Managing the forking policy for your repository You can allow or prevent the forking of a specific private repository owned by an organization. ## Managing pull request reviews in your repository You can limit which users can approve or request changes to a pull requests in a public repository. ## Managing the commit signoff policy for your repository You can require users to automatically sign off on the commits they make to your repository using GitHub's web interface. ## Managing the push policy for your repository You can limit how many branches and tags can be updated in a single push. ## Managing Git LFS objects in archives of your repository You can choose whether Git Large File Storage (Git LFS) objects are included in source code archives created for your repository. ## About email notifications for pushes to your repository You can choose to automatically send email notifications to a specific email address when anyone pushes to the repository. ## Configuring autolinks to reference external resources You can add autolinks to external resources like JIRA issues and Zendesk tickets to help streamline your workflow. ## Managing the automatic closing of issues in your repository You can select whether merged linked pull requests will auto-close your issues. ## Managing GitHub Models in your repository You can enable or disable GitHub Models in your repository.",
    "url": "https://docs.github.com/en/repositories/managing-your-repositorys-settings-and-features/managing-repository-settings",
    "section": "Repository Management",
    "word_count": 276
  },
  {
    "title": "Viewing and understanding files",
    "content": "## Viewing and understanding files Explore file content and trace changes over time to understand a new codebase and its evolution. ## In this article GitHub provides tools to view raw content, trace changes to specific lines, and explore how a file’s content has evolved over time. These insights reveal how code was developed, its current purpose, and its structure, helping you contribute effectively. ## Viewing or copying the raw file content With the raw view, you can view or copy the raw content of a file without any styling. On GitHub, navigate to the main page of the repository. On GitHub, navigate to the main page of the repository. Click the file that you want to view. Click the file that you want to view. In the upper-right corner of the file view, click Raw. In the upper-right corner of the file view, click Raw. Optionally, to copy the raw file content, in the upper-right corner of the file view, click . To download the raw file, click . Optionally, to copy the raw file content, in the upper-right corner of the file view, click . To download the raw file, click . ## Viewing the line-by-line revision history for a file Within the blame view, you can view the line-by-line revision history for an entire file. On the command line, you can also use git blame to view the revision history of lines within a file. For more information, see Git's git blame documentation. On GitHub, navigate to the main page of the repository. On GitHub, navigate to the main page of the repository. Click to open the file whose line history you want to view. Click to open the file whose line history you want to view. Above the file content, click Blame. This view gives you a line-by-line revision history, with the code in a file separated by commit. Each commit lists the author, commit description, and commit date. Above the file content, click Blame. This view gives you a line-by-line revision history, with the code in a file separated by commit. Each commit lists the author, commit description, and commit date. To see versions of a file before a particular commit, click . Alternatively, to see more detail about a particular commit, click the commit message. To see versions of a file before a particular commit, click . Alternatively, to see more detail about a particular commit, click the commit message. To return to the raw code view, above the file content, click Code. If you are viewing a Markdown file, above the file content, you can also click Preview to return to the view with Markdown formatting applied. To return to the raw code view, above the file content, click Code. If you are viewing a Markdown file, above the file content, you can also click Preview to return to the view with Markdown formatting applied. ## Ignore commits in the blame view All revisions specified in the .git-blame-ignore-revs file, which must be in the root directory of your repository, are hidden from the blame view using Git's git blame --ignore-revs-file configuration setting. For more information, see git blame --ignore-revs-file in the Git documentation. .git-blame-ignore-revs git blame --ignore-revs-file git blame --ignore-revs-file In the root directory of your repository, create a file named .git-blame-ignore-revs. In the root directory of your repository, create a file named .git-blame-ignore-revs. .git-blame-ignore-revs Add the commit hashes you want to exclude from the blame view to that file. We recommend the file to be structured as follows, including comments: # .git-blame-ignore-revs # Removed semi-colons from the entire codebase a8940f7fbddf7fad9d7d50014d4e8d46baf30592 # Converted all JavaScript to TypeScript 69d029cec8337c616552756310748c4a507bd75a Add the commit hashes you want to exclude from the blame view to that file. We recommend the file to be structured as follows, including comments: # .git-blame-ignore-revs # Removed semi-colons from the entire codebase a8940f7fbddf7fad9d7d50014d4e8d46baf30592 # Converted all JavaScript to TypeScript 69d029cec8337c616552756310748c4a507bd75a # .git-blame-ignore-revs # Removed semi-colons from the entire codebase a8940f7fbddf7fad9d7d50014d4e8d46baf30592 # Converted all JavaScript to TypeScript 69d029cec8337c616552756310748c4a507bd75a Commit and push the changes. Commit and push the changes. In the blame view, revisions are excluded if the commit introduced new lines or modified existing lines. If the commit was the last to modify a line, it will still appear in blame. You'll see an \"Ignoring revisions in .git-blame-ignore-revs\" banner indicating that some commits may be hidden: This can be useful when a few commits make extensive changes to your code. You can use the file when running git blame locally as well: git blame --ignore-revs-file .git-blame-ignore-revs git blame --ignore-revs-file .git-blame-ignore-revs You can also configure your local git so it always ignores the revs in that file: git config blame.ignoreRevsFile .git-blame-ignore-revs git config blame.ignoreRevsFile .git-blame-ignore-revs ## Bypassing .git-blame-ignore-revs in the blame view .git-blame-ignore-revs If the blame view for a file shows Ignoring revisions in .git-blame-ignore-revs, you can still bypass .git-blame-ignore-revs and see the normal blame view. In the URL, append a ~ to the SHA and the Ignoring revisions in .git-blame-ignore-revs banner will disappear. .git-blame-ignore-revs ## Understanding files with Copilot You'll need access to GitHub Copilot. For more information, see What is GitHub Copilot?. You can also use Copilot to ask about specific lines of code in a file, helping you understand how the code works and reducing the risk of introducing new problems. On GitHub, navigate to a repository and open a file. On GitHub, navigate to a repository and open a file. Do one of the following: To ask a question about the entire file, click the Copilot icon () at the top right of the file view. To ask a question about specific lines within the file: Click the line number for the first line you want to ask about, hold down Shift, then click the line number for the last line you want to select. To ask your own question about the selected lines, click the Copilot icon () to the right of your selection, then type your question in the GitHub Copilot Chat panel. To ask a predefined question, click the drop-down menu beside the Copilot icon, then choose one of the options. Do one of the following: To ask a question about the entire file, click the Copilot icon () at the top right of the file view. To ask a question about the entire file, click the Copilot icon () at the top right of the file view. To ask a question about specific lines within the file: Click the line number for the first line you want to ask about, hold down Shift, then click the line number for the last line you want to select. To ask your own question about the selected lines, click the Copilot icon () to the right of your selection, then type your question in the GitHub Copilot Chat panel. To ask a predefined question, click the drop-down menu beside the Copilot icon, then choose one of the options. To ask a question about specific lines within the file: Click the line number for the first line you want to ask about, hold down Shift, then click the line number for the last line you want to select. To ask your own question about the selected lines, click the Copilot icon () to the right of your selection, then type your question in the GitHub Copilot Chat panel. To ask a predefined question, click the drop-down menu beside the Copilot icon, then choose one of the options. If you clicked the Copilot icon, type a question in the \"Ask Copilot\" box at the bottom of the chat panel and press Enter. For example, if you are asking about the entire file, you could enter: Explain this file. How could I improve this code? How can I test this script? If you are asking about specific lines, you could enter: Explain the function at the selected lines. How could I improve this class? Add error handling to this code. Write a unit test for this method. Copilot responds to your request in the panel. If you clicked the Copilot icon, type a question in the \"Ask Copilot\" box at the bottom of the chat panel and press Enter. For example, if you are asking about the entire file, you could enter: Explain this file. Explain this file. How could I improve this code? How could I improve this code? How can I test this script? How can I test this script? If you are asking about specific lines, you could enter: Explain the function at the selected lines. Explain the function at the selected lines. How could I improve this class? How could I improve this class? Add error handling to this code. Add error handling to this code. Write a unit test for this method. Write a unit test for this method. Copilot responds to your request in the panel. Optionally, after submitting a question, you can click in the text box to stop the response. Optionally, after submitting a question, you can click in the text box to stop the response. You can continue the conversation by asking a follow-up question. For example, you could type \"tell me more\" to get Copilot to expand on its last comment. You can continue the conversation by asking a follow-up question. For example, you could type \"tell me more\" to get Copilot to expand on its last comment.",
    "url": "https://docs.github.com/en/repositories/working-with-files/using-files/viewing-and-understanding-files",
    "section": "Repository Management",
    "word_count": 1556
  },
  {
    "title": "Disabling issues",
    "content": "## Disabling issues You may wish to turn issues off for your repository if you do not accept contributions or bug reports. On GitHub, navigate to the main page of the repository. On GitHub, navigate to the main page of the repository. Under your repository name, click Settings. If you cannot see the \"Settings\" tab, select the dropdown menu, then click Settings. Under your repository name, click Settings. If you cannot see the \"Settings\" tab, select the dropdown menu, then click Settings. Under \"Features,\" deselect Issues. Under \"Features,\" deselect Issues. If you decide to enable issues again in the future, any issues that were previously added will be available. Please contact us through the GitHub Support portal if you want to turn off issues because of abuse from strangers. GitHub does not tolerate abuse. For more information on GitHub's policies, see our Terms of Service and Community Guidelines.",
    "url": "https://docs.github.com/en/repositories/managing-your-repositorys-settings-and-features/enabling-features-for-your-repository/disabling-issues",
    "section": "Repository Management",
    "word_count": 148
  },
  {
    "title": "Classifying your repository with topics",
    "content": "## Classifying your repository with topics To help other people find and contribute to your project, you can add topics to your repository related to your project's intended purpose, subject area, affinity groups, or other important qualities. ## In this article ## About topics With topics, you can explore repositories in a particular subject area, find projects to contribute to, and discover new solutions to a specific problem. Topics appear on the main page of a repository. You can click a topic name to see related topics and a list of other repositories classified with that topic. To browse the most used topics, go to github.com/topics/. You can contribute to GitHub's set of featured topics in the github/explore repository. Repository admins can add any topics they'd like to a repository. Helpful topics to classify a repository include the repository's intended purpose, subject area, community, or language. Additionally, GitHub analyzes public repository content and generates suggested topics that repository admins can accept or reject. Private repository content is not analyzed and does not receive topic suggestions. Public and private repositories can have topics, although you will only see private repositories that you have access to in topic search results. You can search for repositories that are associated with a particular topic. For more information, see Searching for repositories. You can also search for a list of topics on GitHub. For more information, see Searching topics. When creating a topic: Use lowercase letters, numbers, and hyphens. Use 50 characters or less. Add no more than 20 topics. ## Adding topics to your repository Topic names are always public, even if you create the topic from within a private repository. On GitHub, navigate to the main page of the repository. On GitHub, navigate to the main page of the repository. In the top right corner of the page, to the right of \"About\", click . In the top right corner of the page, to the right of \"About\", click . Under \"Topics\", start to type the topic you want to add to your repository to display a dropdown menu of any matching topics. Click the topic you want to add or continue typing to create a new topic. Under \"Topics\", start to type the topic you want to add to your repository to display a dropdown menu of any matching topics. Click the topic you want to add or continue typing to create a new topic. Optional, if there are \"Suggested\" topics displayed under the \"Topics\" field, click to add or to decline the suggested topic. Optional, if there are \"Suggested\" topics displayed under the \"Topics\" field, click to add or to decline the suggested topic. After you've finished adding topics, click Save changes. After you've finished adding topics, click Save changes.",
    "url": "https://docs.github.com/en/repositories/managing-your-repositorys-settings-and-features/customizing-your-repository/classifying-your-repository-with-topics",
    "section": "Repository Management",
    "word_count": 459
  },
  {
    "title": "Moving a file in your repository to Git Large File Storage",
    "content": "## Moving a file in your repository to Git Large File Storage If you've set up Git LFS, and you have an existing file in your repository that needs to be tracked in Git LFS, you need to first remove it from your repository. After installing Git LFS and configuring Git LFS tracking, you can move files from Git's regular tracking to Git LFS. For more information, see Installing Git Large File Storage and Configuring Git Large File Storage. If there are referenced Git LFS files that did not upload successfully, you will receive an error message. For more information, see Resolving Git Large File Storage upload failures. If you get an error that \"this exceeds Git LFS's file size limit of 100 MiB\" when you try to push files to Git, you can use git lfs migrate instead of filter-repo, to move the large file to Git Large File Storage. For more information about the git lfs migrate command, see the Git LFS 2.2.0 release announcement. git lfs migrate filter-repo git lfs migrate Remove the file from the repository's Git history using the filter-repo command. For detailed information on using these, see Removing sensitive data from a repository. filter-repo Configure tracking for your file and push it to Git LFS. For more information on this procedure, see Configuring Git Large File Storage. ## Further reading About Git Large File Storage Collaboration with Git Large File Storage Installing Git Large File Storage",
    "url": "https://docs.github.com/en/repositories/working-with-files/managing-large-files/moving-a-file-in-your-repository-to-git-large-file-storage",
    "section": "Repository Management",
    "word_count": 242
  },
  {
    "title": "About code owners",
    "content": "## About code owners You can use a CODEOWNERS file to define individuals or teams that are responsible for code in a repository. ## Who can use this feature? People with write permissions for the repository can create or edit the CODEOWNERS file and be listed as code owners. People with admin or owner permissions can require that pull requests have to be approved by code owners before they can be merged. You can define code owners in public repositories with GitHub Free and GitHub Free for organizations, and in public and private repositories with GitHub Pro, GitHub Team, GitHub Enterprise Cloud, and GitHub Enterprise Server. For more information, see GitHub’s plans. ## In this article The people you choose as code owners must have write permissions for the repository. When the code owner is a team, that team must be visible and it must have write permissions, even if all the individual members of the team already have write permissions directly, through organization membership, or through another team membership. ## About code owners Code owners are automatically requested for review when someone opens a pull request that modifies code that they own. Code owners are not automatically requested to review draft pull requests. For more information about draft pull requests, see About pull requests. When you mark a draft pull request as ready for review, code owners are automatically notified. If you convert a pull request to a draft, people who are already subscribed to notifications are not automatically unsubscribed. For more information, see Changing the stage of a pull request. When someone with admin or owner permissions has enabled required reviews, they also can optionally require approval from a code owner before the author can merge a pull request in the repository. For more information, see About protected branches. If a file has a code owner, you can see who the code owner is before you open a pull request. In the repository, you can browse to the file and hover over to see a tool tip with codeownership details. ## CODEOWNERS file location To use a CODEOWNERS file, create a new file called CODEOWNERS in the .github/, root, or docs/ directory of the repository, in the branch where you'd like to add the code owners. If CODEOWNERS files exist in more than one of those locations, GitHub will search for them in that order and use the first one it finds. Each CODEOWNERS file assigns the code owners for a single branch in the repository. Thus, you can assign different code owners for different branches, such as @octo-org/codeowners-team for a code base on the default branch and @octocat for a GitHub Pages site on the gh-pages branch. @octo-org/codeowners-team For code owners to receive review requests, the CODEOWNERS file must be on the base branch of the pull request. For example, if you assign @octocat as the code owner for .js files on the gh-pages branch of your repository, @octocat will receive review requests when a pull request with changes to .js files is opened between the head branch and gh-pages. ## CODEOWNERS and forks To trigger review requests, pull requests use the version of CODEOWNERS from the base branch of the pull request. The base branch is the branch that a pull request will modify if the pull request is merged. If you create a pull request from a fork, and the base branch is in the upstream repository, then the pull request will use the CODEOWNERS file from that branch in the upstream repository. If the base branch is a branch within your fork, then the pull request will use the CODEOWNERS file from that branch in your fork, but this will only trigger review requests if the code owners are added to your fork specifically with write access. When you view who is responsible for a file by hovering over , you will see information from the CODEOWNERS file for whichever branch in whichever repository you're looking at. ## CODEOWNERS file size CODEOWNERS files must be under 3 MB in size. A CODEOWNERS file over this limit will not be loaded, which means that code owner information is not shown and the appropriate code owners will not be requested to review changes in a pull request. To reduce the size of your CODEOWNERS file, consider using wildcard patterns to consolidate multiple entries into a single entry. ## CODEOWNERS syntax There are some syntax rules for gitignore files that do not work in CODEOWNERS files: Escaping a pattern starting with # using \\ so it is treated as a pattern and not a comment doesn't work Using ! to negate a pattern doesn't work Using [ ] to define a character range doesn't work A CODEOWNERS file uses a pattern that follows most of the same rules used in gitignore files. The pattern is followed by one or more GitHub usernames or team names using the standard @username or @org/team-name format. Users and teams must have explicit write access to the repository, even if the team's members already have access. @org/team-name If you want to match two or more code owners with the same pattern, all the code owners must be on the same line. If the code owners are not on the same line, the pattern matches only the last mentioned code owner. In most cases, you can also refer to a user by an email address that has been added to their account, for example user@example.com. You cannot use an email address to refer to a managed user account. For more information about managed user accounts, see About Enterprise Managed Users\" in the GitHub Enterprise Cloud documentation. user@example.com CODEOWNERS paths are case sensitive, because GitHub uses a case sensitive file system. Since CODEOWNERS are evaluated by GitHub, even systems that are case insensitive (for example, macOS) must use paths and files that are cased correctly in the CODEOWNERS file. If any line in your CODEOWNERS file contains invalid syntax, that line will be skipped. When you navigate to the CODEOWNERS file in your repository, you can see any errors highlighted. A list of errors in a repository's CODEOWNERS file is also accessible via the API. For more information, see REST API endpoints for repositories. If you specify a user or team that doesn't exist or has insufficient access, a code owner will not be assigned. ## Example of a CODEOWNERS file # This is a comment. # Each line is a file pattern followed by one or more owners. # These owners will be the default owners for everything in # the repo. Unless a later match takes precedence, # @global-owner1 and @global-owner2 will be requested for # review when someone opens a pull request. * @global-owner1 @global-owner2 # Order is important; the last matching pattern takes the most # precedence. When someone opens a pull request that only # modifies JS files, only @js-owner and not the global # owner(s) will be requested for a review. *.js @js-owner #This is an inline comment. # You can also use email addresses if you prefer. They'll be # used to look up users just like we do for commit author # emails. *.go docs@example.com # Teams can be specified as code owners as well. Teams should # be identified in the format @org/team-name. Teams must have # explicit write access to the repository. In this example, # the octocats team in the octo-org organization owns all .txt files. *.txt @octo-org/octocats # In this example, @doctocat owns any files in the build/logs # directory at the root of the repository and any of its # subdirectories. /build/logs/ @doctocat # The `docs/*` pattern will match files like # `docs/getting-started.md` but not further nested files like # `docs/build-app/troubleshooting.md`. docs/* docs@example.com # In this example, @octocat owns any file in an apps directory # anywhere in your repository. apps/ @octocat # In this example, @doctocat owns any file in the `/docs` # directory in the root of your repository and any of its # subdirectories. /docs/ @doctocat # In this example, any change inside the `/scripts` directory # will require approval from @doctocat or @octocat. /scripts/ @doctocat @octocat # In this example, @octocat owns any file in a `/logs` directory such as # `/build/logs`, `/scripts/logs`, and `/deeply/nested/logs`. Any changes # in a `/logs` directory will require approval from @octocat. **/logs @octocat # In this example, @octocat owns any file in the `/apps` # directory in the root of your repository except for the `/apps/github` # subdirectory, as its owners are left empty. Without an owner, changes # to `apps/github` can be made with the approval of any user who has # write access to the repository. /apps/ @octocat /apps/github # In this example, @octocat owns any file in the `/apps` # directory in the root of your repository except for the `/apps/github` # subdirectory, as this subdirectory has its own owner @doctocat /apps/ @octocat /apps/github @doctocat # This is a comment. # Each line is a file pattern followed by one or more owners. # These owners will be the default owners for everything in # the repo. Unless a later match takes precedence, # @global-owner1 and @global-owner2 will be requested for # review when someone opens a pull request. * @global-owner1 @global-owner2 # Order is important; the last matching pattern takes the most # precedence. When someone opens a pull request that only # modifies JS files, only @js-owner and not the global # owner(s) will be requested for a review. *.js @js-owner #This is an inline comment. # You can also use email addresses if you prefer. They'll be # used to look up users just like we do for commit author # emails. *.go docs@example.com # Teams can be specified as code owners as well. Teams should # be identified in the format @org/team-name. Teams must have # explicit write access to the repository. In this example, # the octocats team in the octo-org organization owns all .txt files. *.txt @octo-org/octocats # In this example, @doctocat owns any files in the build/logs # directory at the root of the repository and any of its # subdirectories. /build/logs/ @doctocat # The `docs/*` pattern will match files like # `docs/getting-started.md` but not further nested files like # `docs/build-app/troubleshooting.md`. docs/* docs@example.com # In this example, @octocat owns any file in an apps directory # anywhere in your repository. apps/ @octocat # In this example, @doctocat owns any file in the `/docs` # directory in the root of your repository and any of its # subdirectories. /docs/ @doctocat # In this example, any change inside the `/scripts` directory # will require approval from @doctocat or @octocat. /scripts/ @doctocat @octocat # In this example, @octocat owns any file in a `/logs` directory such as # `/build/logs`, `/scripts/logs`, and `/deeply/nested/logs`. Any changes # in a `/logs` directory will require approval from @octocat. **/logs @octocat # In this example, @octocat owns any file in the `/apps` # directory in the root of your repository except for the `/apps/github` # subdirectory, as its owners are left empty. Without an owner, changes # to `apps/github` can be made with the approval of any user who has # write access to the repository. /apps/ @octocat /apps/github # In this example, @octocat owns any file in the `/apps` # directory in the root of your repository except for the `/apps/github` # subdirectory, as this subdirectory has its own owner @doctocat /apps/ @octocat /apps/github @doctocat ## CODEOWNERS and branch protection Repository owners can update branch protection rules to ensure that changed code is reviewed by the owners of the changed files. Edit your branch protection rule and enable the option \"Require review from Code Owners\". For more information, see About protected branches. When reviews from code owners are required, an approval from any of the owners is sufficient to meet this requirement. For example, let's say that your CODEOWNERS file contains the following line: *.js @global-owner1 @global-owner2 *.js @global-owner1 @global-owner2 This means that changes to JavaScript files could be approved by either @global-owner1 or @global-owner2, but approvals from both are not required. @global-owner1 @global-owner2 To protect a repository fully against unauthorized changes, you also need to define an owner for the CODEOWNERS file itself. The most secure method is to define a CODEOWNERS file in the .github directory of the repository and define the repository owner as the owner of either the CODEOWNERS file (/.github/CODEOWNERS @owner_username) or the whole directory (/.github/ @owner_username). /.github/CODEOWNERS @owner_username /.github/ @owner_username As an alternative to branch protection rules, you can create rulesets. Rulesets have a few advantages over branch protection rules, such as statuses, and better discoverability without requiring admin access. You can also apply multiple rulesets at the same time. For more information, see About rulesets. ## Further reading Creating new files Inviting collaborators to a personal repository Managing an individual's access to an organization repository Managing team access to an organization repository Viewing a pull request review",
    "url": "https://docs.github.com/en/repositories/managing-your-repositorys-settings-and-features/customizing-your-repository/about-code-owners",
    "section": "Repository Management",
    "word_count": 2156
  },
  {
    "title": "Available rules for rulesets",
    "content": "## Available rules for rulesets Learn which rules you can add to a ruleset to protect specific branches and tags in a repository. ## Who can use this feature? Anyone with read access to a repository can view the repository's rulesets. People with admin access to a repository, or a custom role with the \"edit repository rules\" permission, can create, edit, and delete rulesets for a repository. Rulesets are available in public repositories with GitHub Free and GitHub Free for organizations, and in public and private repositories with GitHub Pro, GitHub Team, and GitHub Enterprise Cloud. For more information, see GitHub’s plans. Push rulesets are available for the GitHub Team plan in internal and private repositories, and forks of repositories that have push rulesets enabled. ## In this article You can create branch or tag rulesets to control how users can interact with selected branches and tags in a repository. You can also create push rulesets to block pushes to a private or internal repository and that repository's entire fork network. When you create a ruleset, you can allow certain users to bypass the rules in the ruleset. This can be users with certain roles, specific teams, or GitHub Apps. For push rulesets, bypass permissions apply to a repository and the repository's entire fork network. This means that the only users who can bypass this ruleset for any repository in this repository's entire fork network are the users who can bypass this ruleset in the root repository. For more information on creating rulesets and bypass permissions, see Creating rulesets for a repository. ## Restrict creations If selected, only users with bypass permissions can create branches or tags whose name matches the pattern you specify. ## Restrict updates If selected, only users with bypass permissions can push to branches or tags whose name matches the pattern you specify. ## Restrict deletions If selected, only users with bypass permissions can delete branches or tags whose name matches the pattern you specify. This rule is selected by default. ## Require linear history Enforcing a linear commit history prevents collaborators from pushing merge commits to the targeted branches or tags. This means that any pull requests merged into the branch or tag must use a squash merge or a rebase merge. A strictly linear commit history can help teams revert changes more easily. For more information about merge methods, see About pull request merges. Before you can require a linear commit history, your repository must allow squash merging or rebase merging. For more information, see Configuring pull request merges. ## Require deployments to succeed before merging You can require that changes are successfully deployed to specific environments before a branch can be merged. For example, you can use this rule to ensure that changes are successfully deployed to a staging environment before the changes merge to your default branch. ## Require signed commits When you enable required commit signing on a branch, contributors and bots can only push commits that have been signed and verified to the branch. For more information, see About commit signature verification. Branch protection rules and rulesets behave differently when you create a branch: with rulesets, we check only the commits that aren't accessible from other branches, whereas with branch protection rules, we do not verify signed commits unless you restrict pushes that create matching branches. With both, when you update a branch, we still check all the commits in the specified range, even if a commit is reachable from other branches. With both methods, we use the verified_signature? to confirm if a commit has a valid signature. If not, the update is not accepted. verified_signature? If you have enabled vigilant mode in your account settings, which indicates that your commits will always be signed, any commits that GitHub identifies as \"Partially verified\" are permitted on branches that require signed commits. For more information about vigilant mode, see Displaying verification statuses for all of your commits. If a collaborator pushes an unsigned commit to a branch that requires commit signatures, the collaborator will need to rebase the commit to include a verified signature, then force push the rewritten commit to the branch. You can always push local commits to the branch if the commits are signed and verified. You can also merge signed and verified commits into the branch using a pull request. However, you cannot squash and merge a pull request into the branch on GitHub unless you are the author of the pull request. You can squash and merge pull requests locally. For more information, see Checking out pull requests locally. For more information about merge methods, see About merge methods on GitHub. ## Require a pull request before merging You can require that all changes to the target branch be associated with a pull request. The pull request doesn't necessarily have to be approved, but it must be opened. ## Additional settings If you select Dismiss stale pull request approvals when new commits are pushed and/or Require approval of the most recent reviewable push, manually creating the merge commit for a pull request and pushing it directly to a protected branch will fail, unless the contents of the merge exactly match the merge generated by GitHub for the pull request. In addition, with these settings, approving reviews will be dismissed as stale if the merge base introduces new changes after the review was submitted. The merge base is the commit that is the last common ancestor between the topic branch and the base branch. If the merge base changes, the pull request cannot be merged until someone approves the work again. Repository administrators or custom roles with the \"edit repository rules\" permission can require that all pull requests receive a specific number of approving reviews before someone merges the pull request into a protected branch. You can require approving reviews from people with write permissions in the repository or from a designated code owner. If you enable required reviews, collaborators can only push changes to a branch via a pull request that is approved by the required number of reviewers with write permissions. If someone chooses the Request changes option in a review, then that person must approve the pull request before the pull request can be merged. If a reviewer who requests changes on a pull request isn't available, anyone with write permissions for the repository can dismiss the blocking review. Even after all required reviewers have approved a pull request, collaborators cannot merge the pull request if there are other open pull requests that have a head branch pointing to the same commit with pending or rejected reviews. Someone with write permissions must approve or dismiss the blocking review on the other pull requests first. Optionally, you can choose to dismiss stale pull request approvals when commits are pushed that affect the diff in the pull request. GitHub records the state of the diff at the point when a pull request is approved. This state represents the set of changes that the reviewer approved. If the diff changes from this state (for example, because a contributor pushes new changes to the pull request branch or clicks Update branch, or because a related pull request is merged into the target branch), the approving review is dismissed as stale, and the pull request cannot be merged until someone approves the work again. For information about the target branch, see About pull requests. Optionally, you can choose to require reviews from code owners. If you do, any pull request that modifies content with a code owner must be approved by that code owner before the pull request can be merged into the protected branch. Note that if code has multiple owners, an approval from any of the code owners will be sufficient to meet this requirement. For more information, see About code owners. Optionally, you can require an approval from someone other than the last person to push to a branch before a pull request can be merged. This means at least one other authorized reviewer has approved any changes. For example, the \"last reviewer\" can check that the latest set of changes incorporates feedback from other reviews, and does not add new, unreviewed content. For complex pull requests that require many reviews, requiring an approval from someone other than the last person to push can be a compromise that avoids the need to dismiss all stale reviews: with this option, \"stale\" reviews are not dismissed, and the pull request remains approved as long as someone other than the person who made the most recent changes approves it. Users who have already reviewed a pull request can reapprove after the most recent push to meet this requirement. If you are concerned about pull requests being \"hijacked\" (where unapproved content is added to approved pull requests), it is safer to dismiss stale reviews. Optionally, you can require all comments on the pull request to be resolved before it can be merged to a branch. This ensures that all comments are addressed or acknowledged before merge. Optionally, you can require a merge type of merge, squash, or rebase. This means the targeted branches may only be merged based on the allowed type. Additionally if the repository has disabled a merge method and the ruleset required a different method, the merge will be blocked. See About merge methods on GitHub. ## Require status checks to pass before merging Required status checks ensure that all required CI tests are passing before collaborators can make changes to a branch or tag targeted by your ruleset. Required status checks can be checks or statuses. For more information, see About status checks. You can use the commit status API to allow external services to mark commits with an appropriate status. For more information, see REST API endpoints for commit statuses. After enabling required status checks, all required status checks must pass before collaborators can merge changes into the branch or tag. Any person or integration with write permissions to a repository can set the state of any status check in the repository, but in some cases you may only want to accept a status check from a specific GitHub App. When you add a required status check rule, you can select an app as the expected source of status updates. The app must be installed in the repository with the statuses:write permission, must have recently submitted a check run, and must be associated with a pre-existing required status check in the ruleset. If the status is set by any other person or integration, merging won't be allowed. If you select \"any source,\" you can still manually verify the author of each status, listed in the merge box. statuses:write To troubleshoot issues with configuring status checks in rulesets, see Troubleshooting rules. You can think of required status checks as being either \"loose\" or \"strict.\" The type of required status check you choose determines whether your branch is required to be up to date with the base branch before merging. For status check troubleshooting information, see Troubleshooting required status checks. ## Set code scanning merge protection If your repositories are configured with code scanning, you can use rulesets to prevent pull requests from being merged when one of the following conditions is met: A required tool found a code scanning alert of a severity that is defined in a ruleset. A required tool found a code scanning alert of a severity that is defined in a ruleset. A required code scanning tool's analysis is still in progress. A required code scanning tool's analysis is still in progress. A required code scanning tool is not configured for the repository. A required code scanning tool is not configured for the repository. For more information, see Set code scanning merge protection. For more general information about code scanning, see About code scanning. ## Block force pushes You can prevent users from force pushing to the targeted branches or tags. This rule is enabled by default. If someone force pushes to a branch or tag, commits that other collaborators have based their work on may be removed from the history of the branch or tag. This may lead to merge conflicts or corrupted pull requests. Force pushing can also be used to delete branches or point a branch to commits that were not approved in a pull request. Enabling force pushes will not override any other rules. For example, if a branch requires a linear commit history, you cannot force push merge commits to that branch. ## Restrict file paths Prevent commits that include changes in specified file paths from being pushed to the repository. Limit is 200 entries and up to 200 characters in each entry. You can use fnmatch syntax for this. For example, a restriction targeting test/demo/**/* prevents any pushes to files or folders in the test/demo/ directory. A restriction targeting test/docs/pushrules.md prevents pushes specifically to the pushrules.md file in the test/docs/ directory. For more information, see Creating rulesets for a repository. test/demo/**/* test/docs/pushrules.md pushrules.md ## Restrict file path length Prevent commits that include file paths that exceed a specified character limit from being pushed to the repository. ## Restrict file extensions Prevent commits that include files with specified file extensions from being pushed to the repository. Limit is 200 entries and up to 200 characters in each entry. ## Restrict file size Prevent commits that exceed a specified file size limit from being pushed to the repository.",
    "url": "https://docs.github.com/en/repositories/configuring-branches-and-merges-in-your-repository/managing-rulesets/available-rules-for-rulesets",
    "section": "Repository Management",
    "word_count": 2240
  },
  {
    "title": "Managing the forking policy for your repository",
    "content": "## Managing the forking policy for your repository You can allow or prevent the forking of a specific private repository owned by an organization. ## Who can use this feature? People with admin permissions for a repository can manage the forking policy for the repository. An organization owner must allow forks of private repositories on the organization level before you can allow or disallow forks for a specific repository. For more information, see Managing the forking policy for your organization. You can help prevent sensitive information from being exposed by disabling the ability to fork repositories in your organization. For more information, see Best practices for preventing data leaks in your organization. On GitHub, navigate to the main page of the repository. On GitHub, navigate to the main page of the repository. Under your repository name, click Settings. If you cannot see the \"Settings\" tab, select the dropdown menu, then click Settings. Under your repository name, click Settings. If you cannot see the \"Settings\" tab, select the dropdown menu, then click Settings. Under \"Features\", select Allow forking. If you do not have this option, you may not have permissions to control this setting. Check with the owner of the organization that administers the repository or with the owner of the repository about your access. Under \"Features\", select Allow forking. If you do not have this option, you may not have permissions to control this setting. Check with the owner of the organization that administers the repository or with the owner of the repository about your access. ## Further reading About forks Repository roles for an organization",
    "url": "https://docs.github.com/en/repositories/managing-your-repositorys-settings-and-features/managing-repository-settings/managing-the-forking-policy-for-your-repository",
    "section": "Repository Management",
    "word_count": 266
  },
  {
    "title": "Managing releases in a repository",
    "content": "## Managing releases in a repository You can create releases to bundle and deliver iterations of a project to users. ## Who can use this feature? Repository collaborators and people with write access to a repository can create, edit, and delete a release. ## Tool navigation ## In this article ## About release management You can create new releases with release notes, @mentions of contributors, and links to binary files, as well as edit or delete existing releases. You can also create, modify, and delete releases by using the Releases API. For more information, see REST API endpoints for releases in the REST API documentation. You can also publish an action from a specific release in GitHub Marketplace. For more information, see Publishing actions in GitHub Marketplace. You can choose whether Git Large File Storage (Git LFS) objects are included in the ZIP files and tarballs that GitHub creates for each release. For more information, see Managing Git LFS objects in archives of your repository. ## Creating a release On GitHub, navigate to the main page of the repository. On GitHub, navigate to the main page of the repository. To the right of the list of files, click Releases. To the right of the list of files, click Releases. At the top of the page, click Draft a new release. At the top of the page, click Draft a new release. To choose a tag for the release, select the Choose a tag dropdown menu. To use an existing tag, click the tag. To create a new tag, type a version number for your release, then click Create new tag. To choose a tag for the release, select the Choose a tag dropdown menu. To use an existing tag, click the tag. To create a new tag, type a version number for your release, then click Create new tag. If you created a new tag, select the Target dropdown menu, then click the branch that contains the project you want to release. If you created a new tag, select the Target dropdown menu, then click the branch that contains the project you want to release. Optionally, above the description field, select the Previous tag dropdown menu, then click the tag that identifies the previous release. Optionally, above the description field, select the Previous tag dropdown menu, then click the tag that identifies the previous release. In the \"Release title\" field, type a title for your release. In the \"Release title\" field, type a title for your release. In the \"Describe this release\" field, type a description for your release. If you @mention anyone in the description, the published release will include a Contributors section with an avatar list of all the mentioned users. Alternatively, you can automatically generate your release notes by clicking Generate release notes. In the \"Describe this release\" field, type a description for your release. If you @mention anyone in the description, the published release will include a Contributors section with an avatar list of all the mentioned users. Alternatively, you can automatically generate your release notes by clicking Generate release notes. Optionally, to include binary files such as compiled programs in your release, drag and drop or manually select files in the binaries box. Optionally, to include binary files such as compiled programs in your release, drag and drop or manually select files in the binaries box. Optionally, to notify users that the release is not ready for production and may be unstable, select This is a pre-release. Optionally, to notify users that the release is not ready for production and may be unstable, select This is a pre-release. Optionally, select Set as latest release. If you do not select this option, the latest release label will automatically be assigned based on semantic versioning. Optionally, select Set as latest release. If you do not select this option, the latest release label will automatically be assigned based on semantic versioning. Optionally, if GitHub Discussions is enabled for the repository, create a discussion for the release. Select Create a discussion for this release. Select the Category dropdown menu, then click a category for the release discussion. Optionally, if GitHub Discussions is enabled for the repository, create a discussion for the release. Select Create a discussion for this release. Select the Category dropdown menu, then click a category for the release discussion. If you're ready to publicize your release, click Publish release. To work on the release later, click Save draft. You can then view your published or draft releases in the releases feed for your repository. For more information, see Viewing your repository's releases and tags. If you're ready to publicize your release, click Publish release. To work on the release later, click Save draft. You can then view your published or draft releases in the releases feed for your repository. For more information, see Viewing your repository's releases and tags. To learn more about GitHub CLI, see About GitHub CLI. To create a release, use the gh release create subcommand. Replace tag with the desired tag for the release. gh release create TAG To create a release, use the gh release create subcommand. Replace tag with the desired tag for the release. gh release create gh release create TAG gh release create TAG Follow the interactive prompts. Alternatively, you can specify arguments to skip these prompts. For more information about possible arguments, see the GitHub CLI manual. For example, this command creates a prerelease with the specified title and notes. gh release create v1.3.2 --title \"v1.3.2 (beta)\" --notes \"this is a public preview release\" --prerelease Follow the interactive prompts. Alternatively, you can specify arguments to skip these prompts. For more information about possible arguments, see the GitHub CLI manual. For example, this command creates a prerelease with the specified title and notes. gh release create v1.3.2 --title \"v1.3.2 (beta)\" --notes \"this is a public preview release\" --prerelease gh release create v1.3.2 --title \"v1.3.2 (beta)\" --notes \"this is a public preview release\" --prerelease If you @mention any GitHub users in the notes, the published release will include a Contributors section with an avatar list of all the mentioned users. ## Editing a release If you have enabled immutable releases for your repository, you can only edit the title and release notes after a release is published. See Immutable releases. On GitHub, navigate to the main page of the repository. On GitHub, navigate to the main page of the repository. To the right of the list of files, click Releases. To the right of the list of files, click Releases. Next to the release you want to edit, click . Next to the release you want to edit, click . Edit the details for the release in the form, then click Update release. If you add or remove any @mentions of GitHub users in the description, those users will be added or removed from the avatar list in the Contributors section of the release. Edit the details for the release in the form, then click Update release. If you add or remove any @mentions of GitHub users in the description, those users will be added or removed from the avatar list in the Contributors section of the release. To edit a release, use the gh release edit subcommand. Replace TAG with the tag representing the release you wish to edit. For example, to edit the title for a release, use the following code, replacing NEW-TITLE with the updated title: gh release edit TAG -t \"NEW-TITLE\" For more information about possible arguments, see the GitHub CLI manual. To edit a release, use the gh release edit subcommand. Replace TAG with the tag representing the release you wish to edit. For example, to edit the title for a release, use the following code, replacing NEW-TITLE with the updated title: gh release edit gh release edit TAG -t \"NEW-TITLE\" gh release edit TAG -t \"NEW-TITLE\" For more information about possible arguments, see the GitHub CLI manual. ## Deleting a release On GitHub, navigate to the main page of the repository. On GitHub, navigate to the main page of the repository. To the right of the list of files, click Releases. To the right of the list of files, click Releases. On the right side of the page, next to the release you want to delete, click . On the right side of the page, next to the release you want to delete, click . Click Delete this release. Click Delete this release. To delete a release, use the gh release delete subcommand. Replace tag with the tag of the release to delete. Use the -y flag to skip confirmation. gh release delete TAG -y To delete a release, use the gh release delete subcommand. Replace tag with the tag of the release to delete. Use the -y flag to skip confirmation. gh release delete gh release delete TAG -y gh release delete TAG -y",
    "url": "https://docs.github.com/en/repositories/releasing-projects-on-github/managing-releases-in-a-repository",
    "section": "Repository Management",
    "word_count": 1482
  },
  {
    "title": "Licensing a repository",
    "content": "## Licensing a repository Public repositories on GitHub are often used to share open source software. For your repository to truly be open source, you'll need to license it so that others are free to use, change, and distribute the software. ## In this article ## Choosing the right license We created choosealicense.com, to help you understand how to license your code. A software license tells others what they can and can't do with your source code, so it's important to make an informed decision. You're under no obligation to choose a license. However, without a license, the default copyright laws apply, meaning that you retain all rights to your source code and no one may reproduce, distribute, or create derivative works from your work. If you're creating an open source project, we strongly encourage you to include an open source license. The Open Source Guide provides additional guidance on choosing the correct license for your project. If you publish your source code in a public repository on GitHub, according to the Terms of Service, other users of GitHub.com have the right to view and fork your repository. If you have already created a repository and no longer want users to have access to the repository, you can make the repository private. When you change the visibility of a repository to private, existing forks or local copies created by other users will still exist. For more information, see Setting repository visibility. ## Determining the location of your license Most people place their license text in a file named LICENSE.txt (or LICENSE.md or LICENSE.rst) in the root of the repository; here's an example from Hubot. LICENSE.txt LICENSE.rst Some projects include information about their license in their README. For example, a project's README may include a note saying \"This project is licensed under the terms of the MIT license.\" As a best practice, we encourage you to include the license file with your project. ## Searching GitHub by license type You can filter repositories based on their license or license family using the license qualifier and the exact license keyword. Artistic-2.0 BSD-2-Clause BSD-3-Clause BSD-3-Clause-Clear BSD-4-Clause CC-BY-SA-4.0 When you search by a family license, your results will include all licenses in that family. For example, when you use the query license:gpl, your results will include repositories licensed under GNU General Public License v2.0 and GNU General Public License v3.0. For more information, see Searching for repositories. license:gpl ## Detecting a license The open source Ruby gem Licensee compares the repository's LICENSE file to a short list of known licenses. Licensee also provides the Licenses API and gives us insight into how repositories on GitHub are licensed. If your repository is using a license that isn't listed on the Choose a License website, you can request including the license. If your repository is using a license that is listed on the Choose a License website and it's not displaying clearly at the top of the repository page, it may contain multiple licenses or other complexity. To have your license detected, simplify your LICENSE file and note the complexity somewhere else, such as your repository's README file. ## Applying a license to a repository with an existing license The license picker is only available when you create a new project on GitHub. You can manually add a license using the browser. For more information on adding a license to a repository, see Adding a license to a repository. The goal of GitHub's open source licensing efforts is to provide a starting point to help you make an informed choice. GitHub displays license information to help users get information about open source licenses and the projects that use them. We hope it helps, but please keep in mind that we’re not lawyers and that we make mistakes like everyone else. For that reason, GitHub provides the information on an \"as-is\" basis and makes no warranties regarding any information or licenses provided on or through it, and disclaims liability for damages resulting from using the license information. If you have any questions regarding the right license for your code or any other legal issues relating to it, it’s always best to consult with a professional. ## Further reading The Open Source Guides' section The Legal Side of Open Source GitHub Skills",
    "url": "https://docs.github.com/en/repositories/managing-your-repositorys-settings-and-features/customizing-your-repository/licensing-a-repository",
    "section": "Repository Management",
    "word_count": 714
  },
  {
    "title": "Analyzing changes to a repository's content",
    "content": "## Analyzing changes to a repository's content You can see the changes to the content of a repository by analyzing the repository's commits, commit frequency, and content additions and deletions. ## Who can use this feature? This repository insights graph is available in public repositories with GitHub Free and GitHub Free for organizations, and in public and private repositories with GitHub Pro, GitHub Team, GitHub Enterprise Cloud, and GitHub Enterprise Server. For more information, see About repository graphs and GitHub’s plans. ## In this article ## Visualizing commits in a repository Certain contributor, commit, and code frequency insights are only available for repositories that have fewer than 10,000 commits. You can see all commits made to a repository in the past year (excluding merge commits) in the Commit graph. The top graph shows commits for the entire year by week. The bottom graph shows the average number of commits by day of the week for the selected week. ## Accessing the commits graph On GitHub, navigate to the main page of the repository. On GitHub, navigate to the main page of the repository. Under your repository name, click Insights. Under your repository name, click Insights. In the left sidebar, click Commits. In the left sidebar, click Commits. ## Visualizing additions and deletion to content in a repository Certain contributor, commit, and code frequency insights are only available for repositories that have fewer than 10,000 commits. The code frequency graph displays the content additions and deletions for each week in a repository's history. ## Accessing the code frequency graph On GitHub, navigate to the main page of the repository. On GitHub, navigate to the main page of the repository. Under your repository name, click Insights. Under your repository name, click Insights. In the left sidebar, click Code frequency. In the left sidebar, click Code frequency. Optionally, to view the graph as a table, in the top-right corner of the graph, click . Then click View as table. Optionally, to view the graph as a table, in the top-right corner of the graph, click . Then click View as table. Optionally, to download a CSV or PNG, in the top-right corner of the graph, click . Then click Download CSV or Download PNG. Optionally, to download a CSV or PNG, in the top-right corner of the graph, click . Then click Download CSV or Download PNG. If you want to see a detailed history of changes to a repository, you can use the activity view. The activity view displays all pushes, merges, force pushes, and branch changes, and associates these changes with commits and authenticated users. For more information, see Using the activity view to see changes to a repository.",
    "url": "https://docs.github.com/en/repositories/viewing-activity-and-data-for-your-repository/analyzing-changes-to-a-repositorys-content",
    "section": "Repository Management",
    "word_count": 448
  },
  {
    "title": "About large files on GitHub",
    "content": "## About large files on GitHub GitHub limits the size of files you can track in regular Git repositories. Learn how to track or remove files that are beyond the limit. ## Platform navigation ## In this article ## About size limits on GitHub GitHub tries to provide abundant storage for all Git repositories, although there are hard limits for file and repository sizes. To ensure performance and reliability for our users, we actively monitor signals of overall repository health. Repository health is a function of various interacting factors, including size, commit frequency, contents, and structure. ## File size limits GitHub limits the size of files allowed in repositories. If you attempt to add or update a file that is larger than 50 MiB, you will receive a warning from Git. The changes will still successfully push to your repository, but you can consider removing the commit to minimize performance impact. For more information, see Removing files from a repository's history. If you add a file to a repository via a browser, the file can be no larger than 25 MiB. For more information, see Adding a file to a repository. GitHub blocks files larger than 100 MiB. To track files beyond this limit, you must use Git Large File Storage (Git LFS). For more information, see About Git Large File Storage. If you need to distribute large files within your repository, you can create releases on GitHub.com instead of tracking the files. For more information, see Distributing large binaries. Git is not designed to handle large SQL files. To share large databases with other developers, we recommend using a file sharing service. ## Repository size limits We recommend repositories remain small, ideally less than 1 GB, and less than 5 GB is strongly recommended. Smaller repositories are faster to clone and easier to work with and maintain. If your repository excessively impacts our infrastructure, you might receive an email from GitHub Support asking you to take corrective action. We try to be flexible, especially with large projects that have many collaborators, and will work with you to find a resolution whenever possible. You can prevent your repository from impacting our infrastructure by effectively managing your repository's size and overall health. You can find advice and a tool for repository analysis in the github/git-sizer repository. github/git-sizer External dependencies can cause Git repositories to become very large. To avoid filling a repository with external dependencies, we recommend you use a package manager. Popular package managers for common languages include Bundler, Node's Package Manager, and Maven. These package managers support using Git repositories directly, so you don't need pre-packaged sources. Git is not designed to serve as a backup tool. However, there are many solutions specifically designed for performing backups, such as Arq, Carbonite, and CrashPlan. ## Removing files from a repository's history These procedures will permanently remove files from the repository on your computer and GitHub.com. If the file is important, make a local backup copy in a directory outside of the repository. ## Removing a file added in the most recent unpushed commit If the file was added with your most recent commit, and you have not pushed to GitHub.com, you can delete the file and amend the commit: Open TerminalTerminalGit Bash. Open TerminalTerminalGit Bash. Change the current working directory to your local repository. Change the current working directory to your local repository. To remove the file, enter git rm --cached: $ git rm --cached GIANT_FILE # Stage our giant file for removal, but leave it on disk To remove the file, enter git rm --cached: git rm --cached $ git rm --cached GIANT_FILE # Stage our giant file for removal, but leave it on disk $ git rm --cached GIANT_FILE # Stage our giant file for removal, but leave it on disk Commit this change using --amend -CHEAD: $ git commit --amend -CHEAD # Amend the previous commit with your change # Simply making a new commit won't work, as you need # to remove the file from the unpushed history as well Commit this change using --amend -CHEAD: --amend -CHEAD $ git commit --amend -CHEAD # Amend the previous commit with your change # Simply making a new commit won't work, as you need # to remove the file from the unpushed history as well $ git commit --amend -CHEAD # Amend the previous commit with your change # Simply making a new commit won't work, as you need # to remove the file from the unpushed history as well Push your commits to GitHub.com: $ git push # Push our rewritten, smaller commit Push your commits to GitHub.com: $ git push # Push our rewritten, smaller commit $ git push # Push our rewritten, smaller commit ## Removing a file that was added in an earlier commit If you added a file in an earlier commit, you need to remove it from the repository's history. To remove files from the repository's history, we recommend the git filter-repo command. For more information see Removing sensitive data from a repository. git filter-repo Alternatively, if you don't want to install an additional tool, you could use an interactive rebase to remove problematic commits. To do this: You must know which commit(s) added or modified the file in question. The commit(s) must be part of only one branch. The one branch that the commits belong to must have had no merges since the commit(s) were applied. For more information about interactive rebases, see Using Git rebase on the command line. If you are unsure if you meet the necessary conditions for fixing with an interactive rebase, you should use git filter-repo. git filter-repo ## Distributing large binaries If you need to distribute large files within your repository, you can create releases on GitHub.com. Releases allow you to package software, release notes, and links to binary files, for other people to use. For more information, visit About releases. We don't limit the total size of the binary files in the release or the bandwidth used to deliver them. However, each individual file must be smaller than 2 GiB.",
    "url": "https://docs.github.com/en/repositories/working-with-files/managing-large-files/about-large-files-on-github",
    "section": "Repository Management",
    "word_count": 1016
  },
  {
    "title": "Resolving Git Large File Storage upload failures",
    "content": "## Resolving Git Large File Storage upload failures If your Git LFS files didn't upload properly, you can take several steps to troubleshoot the upload error. The Git LFS integrity check ensures that all referenced Git LFS files in a push have been uploaded properly. If the check detects referenced files that have not been uploaded, you will receive an error message and your push will be blocked. To resolve the error message, you must reinstall your local Git LFS client to ensure that the referenced Git LFS files can be properly uploaded in the future. Open Terminal. Open Terminal. Reinstall Git LFS. git lfs install Reinstall Git LFS. git lfs install git lfs install Push all referenced Git LFS files. git lfs push --all origin Push all referenced Git LFS files. git lfs push --all origin git lfs push --all origin",
    "url": "https://docs.github.com/en/repositories/working-with-files/managing-large-files/resolving-git-large-file-storage-upload-failures",
    "section": "Repository Management",
    "word_count": 142
  },
  {
    "title": "Managing rulesets for a repository",
    "content": "## Managing rulesets for a repository You can edit, monitor, and delete existing rulesets in a repository to alter how people can interact with specific branches and tags. ## Who can use this feature? Anyone with read access to a repository can view the repository's rulesets. People with admin access to a repository, or a custom role with the \"edit repository rules\" permission, can create, edit, and delete rulesets for a repository. Rulesets are available in public repositories with GitHub Free and GitHub Free for organizations, and in public and private repositories with GitHub Pro, GitHub Team, and GitHub Enterprise Cloud. For more information, see GitHub’s plans. Push rulesets are available for the GitHub Team plan in internal and private repositories, and forks of repositories that have push rulesets enabled. ## In this article After creating a ruleset, you can still make changes to it. For example, you can add rules to better protect your branches or tags, or you can temporarily disable a ruleset to troubleshoot any unintended effects on the contributor experience for your repository. You can use the REST and GraphQL APIs to manage rulesets. For more information, see REST API endpoints for rules and Mutations. ## Viewing rulesets for a repository On the \"Rulesets\" page, anyone with read access to the repository can view the active rulesets targeting a certain branch, tag, or push restriction. For push rulesets for forked repositories, the \"Rulesets\" page will indicate that the ruleset is managed by the source repository where the rule is applied. On GitHub, navigate to the main page of the repository. On GitHub, navigate to the main page of the repository. From the file tree view on the left, select the branch dropdown menu, then click View all branches. You can also find the branch dropdown menu at the top of the integrated file editor. From the file tree view on the left, select the branch dropdown menu, then click View all branches. You can also find the branch dropdown menu at the top of the integrated file editor. To the left of the branch name, click . Tip Only branches that have a ruleset have a icon adjacent to their name. To the left of the branch name, click . Only branches that have a ruleset have a icon adjacent to their name. Optionally, to filter the results click the tabs or use the \"Search branches\" search bar. Optionally, to filter the results click the tabs or use the \"Search branches\" search bar. Click the name of the ruleset you want to view. Click the name of the ruleset you want to view. You can also view active ruselets: By adding the /rules slug to the repository's URL. For example, to view the rules of the open source documentation repository at GitHub, you would go to https://github.com/github/docs/rules. By adding the /rules slug to the repository's URL. For example, to view the rules of the open source documentation repository at GitHub, you would go to https://github.com/github/docs/rules. In the merge box if there are rules blocking the merging of a pull request. In the merge box if there are rules blocking the merging of a pull request. ## Editing a ruleset You can edit a ruleset to change parts of the ruleset, such as the name, bypass permissions, or rules. You can also edit a ruleset to change its status, such as if you want to enable or temporarily disable a ruleset. On GitHub, navigate to the main page of the repository. On GitHub, navigate to the main page of the repository. Under your repository name, click Settings. If you cannot see the \"Settings\" tab, select the dropdown menu, then click Settings. Under your repository name, click Settings. If you cannot see the \"Settings\" tab, select the dropdown menu, then click Settings. In the left sidebar, under \"Code and automation,\" click Rules, then click Rulesets. In the left sidebar, under \"Code and automation,\" click Rules, then click Rulesets. On the \"Rulesets\" page, click the name of the ruleset you want to edit. On the \"Rulesets\" page, click the name of the ruleset you want to edit. Change the ruleset as required. For information on the available rules, see Available rules for rulesets. Change the ruleset as required. For information on the available rules, see Available rules for rulesets. At the bottom of the page, click Save changes. At the bottom of the page, click Save changes. ## Deleting a ruleset If you want to temporarily disable a ruleset but do not want to delete it, you can set the ruleset's status to \"Disabled.\" For more information, see Editing a ruleset. On GitHub, navigate to the main page of the repository. On GitHub, navigate to the main page of the repository. Under your repository name, click Settings. If you cannot see the \"Settings\" tab, select the dropdown menu, then click Settings. Under your repository name, click Settings. If you cannot see the \"Settings\" tab, select the dropdown menu, then click Settings. In the left sidebar, under \"Code and automation,\" click Rules, then click Rulesets. In the left sidebar, under \"Code and automation,\" click Rules, then click Rulesets. Click the name of the ruleset you want to delete. Click the name of the ruleset you want to delete. To the right of the ruleset's name, select , then click Delete ruleset. To the right of the ruleset's name, select , then click Delete ruleset. ## Using ruleset history Ruleset history lists events triggered by changes that affect your rulesets within the last 180 days. You can view all the changes to a ruleset and revert back to a specific iteration. You can also download a JSON file containing the ruleset's configuration at a specific iteration. The bypass list of a ruleset is excluded from the exported JSON file. On GitHub, navigate to the main page of the repository. On GitHub, navigate to the main page of the repository. Under your repository name, click Settings. If you cannot see the \"Settings\" tab, select the dropdown menu, then click Settings. Under your repository name, click Settings. If you cannot see the \"Settings\" tab, select the dropdown menu, then click Settings. In the left sidebar, under \"Code and automation,\" click Rules, then click Rulesets. In the left sidebar, under \"Code and automation,\" click Rules, then click Rulesets. To view the history of changes to the ruleset, select to the right of the ruleset's name, then click History. To view the history of changes to the ruleset, select to the right of the ruleset's name, then click History. To the right of the specific iteration, select , then click Compare changes, Restore, or Download. To the right of the specific iteration, select , then click Compare changes, Restore, or Download. ## Importing a ruleset You can import an existing ruleset using a JSON file. This can be useful if you want to apply the same ruleset to multiple repositories or organizations. On GitHub, navigate to the main page of the repository. On GitHub, navigate to the main page of the repository. Under your repository name, click Settings. If you cannot see the \"Settings\" tab, select the dropdown menu, then click Settings. Under your repository name, click Settings. If you cannot see the \"Settings\" tab, select the dropdown menu, then click Settings. In the left sidebar, under \"Code and automation,\" click Rules, then click Rulesets. In the left sidebar, under \"Code and automation,\" click Rules, then click Rulesets. Select the New ruleset dropdown, then click Import a ruleset. Select the New ruleset dropdown, then click Import a ruleset. Open the exported JSON file. Open the exported JSON file. Review the imported ruleset and click Create. Review the imported ruleset and click Create.",
    "url": "https://docs.github.com/en/repositories/configuring-branches-and-merges-in-your-repository/managing-rulesets/managing-rulesets-for-a-repository",
    "section": "Repository Management",
    "word_count": 1287
  },
  {
    "title": "Repository limits",
    "content": "## Repository limits Learn about limitations for repositories. ## In this article Certain types of repository resources can be quite large, requiring excessive processing on GitHub. Because of this, limits are set to ensure requests complete in a reasonable amount of time. Exceeding the recommended maximum limit increases the risk of degraded repository health, which includes, but is not limited to, slow response times for basic Git operations and UI latency. While following these guidelines can improve repository stability, it does not guarantee supportability, as other factors may lead to unexpected behavior. Most of the limits below affect both GitHub and the API. ## Repository size To ensure optimal performance and manageability, we recommend staying within the following maximum limits for repository structure and size. On-disk size: 10 GB On-disk size refers to the size of the .git folder (the compressed form of the repository). Large repositories can slow down fetch operations and increase clone times for developers and CI. To manage repository size: Use Git Large File Storage (Git LFS) for binary files. Store programmatically generated files outside of Git, such as in object storage. On-disk size: 10 GB On-disk size refers to the size of the .git folder (the compressed form of the repository). Large repositories can slow down fetch operations and increase clone times for developers and CI. To manage repository size: Use Git Large File Storage (Git LFS) for binary files. Store programmatically generated files outside of Git, such as in object storage. Directory width (number of entries in a single directory): 3,000 Directories containing numerous frequently modified files can significantly increase repository maintenance costs and degrade the performance of basic Git operations. Segmenting files into a shallow directory structure will reduce the size of these trees and result in less new data created. Directory width (number of entries in a single directory): 3,000 Directories containing numerous frequently modified files can significantly increase repository maintenance costs and degrade the performance of basic Git operations. Segmenting files into a shallow directory structure will reduce the size of these trees and result in less new data created. Directory depth: 50 Deep directory trees can make history-walking operations slower. Directory depth: 50 Deep directory trees can make history-walking operations slower. Number of branches: 5,000 Large numbers of branches can result in unnecessary data in fetch operations, leading to slow transfer times or in extreme cases throttled repository performance. Number of branches: 5,000 Large numbers of branches can result in unnecessary data in fetch operations, leading to slow transfer times or in extreme cases throttled repository performance. To avoid throttling and performance issues, we recommend staying within the following operational limits. Push size: This limit is enforced at 2GB. Push size: This limit is enforced at 2GB. Single object size: The recommended maximum limit is 1MB. This is enforced at 100MB. To track large files in a Git repository, we recommend using Git LFS. See About Git Large File Storage. Single object size: The recommended maximum limit is 1MB. This is enforced at 100MB. To track large files in a Git repository, we recommend using Git LFS. See About Git Large File Storage. Git read operations (e.g. fetches, clones): The recommended maximum limit is 15 operations per second per repository. Large amounts of read operations can result in throttled performance for a repository. Automated processes such as CI, machine users, or third-party applications, can degrade a repository's performance in some cases. Consider optimizing your CI's clone strategy and/or using a repository cache server. Note that shallow clones will impose less cost and burden on the server than full clones and therefore may perform better. Git read operations (e.g. fetches, clones): The recommended maximum limit is 15 operations per second per repository. Large amounts of read operations can result in throttled performance for a repository. Automated processes such as CI, machine users, or third-party applications, can degrade a repository's performance in some cases. Consider optimizing your CI's clone strategy and/or using a repository cache server. Note that shallow clones will impose less cost and burden on the server than full clones and therefore may perform better. Push rate: The recommended maximum limit is 6 pushes per minute per repository. Push rate: The recommended maximum limit is 6 pushes per minute per repository. ## Text limits GitHub displays formatted previews of some files, such as Markdown and Mermaid diagrams. GitHub always attempts to render these previews if the files are small (generally less than 2 MB), but more complex files may time out and either fall back to plain text or not be displayed at all. These files are always available in their raw formats, which are served through raw.githubusercontent.com; for example, https://raw.githubusercontent.com/octocat/Spoon-Knife/main/index.html. Click the Raw button to get the raw URL for a file. raw.githubusercontent.com https://raw.githubusercontent.com/octocat/Spoon-Knife/main/index.html ## Pull requests limits To reduce delays and performance issues in repositories with high pull request activity, we recommend staying within the following limits. Open pull requests (against the same branch): 1,000 Having many open pull requests targeting the same branch can slow down mergeability checks or lead to timeouts. If you're using a merge queue, consider disabling the \"require this branch to be up to date before merging\" setting. This limits mergeability checks to only the pull requests in the queue. Open pull requests (against the same branch): 1,000 Having many open pull requests targeting the same branch can slow down mergeability checks or lead to timeouts. If you're using a merge queue, consider disabling the \"require this branch to be up to date before merging\" setting. This limits mergeability checks to only the pull requests in the queue. Pull request merge rate: 1 merged pull request per minute Each merge triggers mergeability checks for all open pull requests, which can cause performance bottlenecks—especially in busy repositories. This can also lead to a race-to-merge situation that impacts developer productivity. To reduce load, disable the \"require this branch to be up to date before merging\" setting when using a merge queue. Pull request merge rate: 1 merged pull request per minute Each merge triggers mergeability checks for all open pull requests, which can cause performance bottlenecks—especially in busy repositories. This can also lead to a race-to-merge situation that impacts developer productivity. To reduce load, disable the \"require this branch to be up to date before merging\" setting when using a merge queue. ## Diff limits Because diffs can become very large, we impose these limits on diffs for commits, pull requests, and compare views: In a pull request, no total diff may exceed 20,000 lines that you can load or 1 MB of raw diff data. No single file's diff may exceed 20,000 lines that you can load or 500 KB of raw diff data. Four hundred lines and 20 KB are automatically loaded for a single file. The maximum number of files in a single diff is limited to 300. The maximum number of renderable files (such as images, PDFs, and GeoJSON files) in a single diff is limited to 25. Some portions of a limited diff may be displayed, but anything exceeding the limit is not shown. ## Commit listings limits The compare view and pull requests pages display a list of commits between the base and head revisions. These lists are limited to 250 commits. If they exceed that limit, a note indicates that additional commits are present (but they're not shown). The maximum count of commits displayed on the Commits tab is 10,000. Use other tools such as git rev-list --count mybranch to count and enumerate a high volume of commits when needed. git rev-list --count mybranch ## Rebase limits Merging a pull request using the \"Rebase and merge\" option is limited to 100 commits. If you have a pull request with more than 100 commits, you need to create a merge commit, squash and merge, or split the commits up into multiple pull requests. ## Organization and account limits Organizations and accounts may not exceed 100,000 repositories. When an account surpasses 50,000 repositories, a banner will appear, noting the approaching limit. Additionally, administrators will receive email notifications, and the audit log will update every additional 5,000 repositories created. See About repositories. ## Integrations and GitHub Apps When building an integration on GitHub, store user-generated data in their own GitHub accounts rather than centralizing it in your account. This ensures users retain full control over their work and helps you avoid exceeding repository limits.",
    "url": "https://docs.github.com/en/repositories/creating-and-managing-repositories/repository-limits",
    "section": "Repository Management",
    "word_count": 1403
  },
  {
    "title": "Using files",
    "content": "## Using files You can navigate and track changes in the code in your files. ## Navigating code on GitHub You can understand the relationships within and across repositories by navigating code directly in GitHub. ## Viewing and understanding files Explore file content and trace changes over time to understand a new codebase and its evolution. ## Getting permanent links to files When viewing a file on GitHub, you can press the \"y\" key to update the URL to a permalink to the exact version of the file you see. ## Downloading source code archives You can download a snapshot of the code in your repository. ## Working with non-code files GitHub supports rendering and diffing in a number of non-code file formats.",
    "url": "https://docs.github.com/en/repositories/working-with-files/using-files",
    "section": "Repository Management",
    "word_count": 123
  },
  {
    "title": "Quickstart for repositories",
    "content": "## Quickstart for repositories Learn how to create a new repository and commit your first change in 5 minutes. ## Tool navigation ## In this article ## Create a repository GitHub repositories store a variety of projects. In this guide, you'll create a repository and commit your first change. In the upper-right corner of any page, select , then click New repository. In the upper-right corner of any page, select , then click New repository. Type a short, memorable name for your repository. For example, \"hello-world\". Type a short, memorable name for your repository. For example, \"hello-world\". Optionally, add a description of your repository. For example, \"My first repository on GitHub.\" Optionally, add a description of your repository. For example, \"My first repository on GitHub.\" Choose a repository visibility. For more information, see About repositories. Choose a repository visibility. For more information, see About repositories. Select Initialize this repository with a README. Select Initialize this repository with a README. Click Create repository. Click Create repository. Congratulations! You've successfully created your first repository, and initialized it with a README file. To learn more about GitHub CLI, see About GitHub CLI. In the command line, navigate to the directory where you would like to create a local clone of your new project. To create a repository for your project, use the gh repo create subcommand. When prompted, select Create a new repository on GitHub from scratch and enter the name of your new project. If you want your project to belong to an organization instead of to your personal account, specify the organization name and project name with organization-name/project-name. gh repo create organization-name/project-name Follow the interactive prompts. To clone the repository locally, confirm yes when asked if you would like to clone the remote project directory. Alternatively, to skip the prompts supply the repository name and a visibility flag (--public, --private, or --internal). For example, gh repo create project-name --public. To clone the repository locally, pass the --clone flag. For more information about possible arguments, see the GitHub CLI manual. gh repo create project-name --public ## Commit your first change A commit is like a snapshot of all the files in your project at a particular point in time. When you created your new repository, you initialized it with a README file. README files are a great place to describe your project in more detail, or add some documentation such as how to install or use your project. The contents of your README file are automatically shown on the front page of your repository. Let's commit a change to the README file. In your repository's list of files, select README.md. In your repository's list of files, select README.md. In the upper right corner of the file view, click to open the file editor. In the upper right corner of the file view, click to open the file editor. In the text box, type some information about yourself. In the text box, type some information about yourself. Above the new content, click Preview. Above the new content, click Preview. Review the changes you made to the file. If you select Show diff, you will see the new content in green. Review the changes you made to the file. If you select Show diff, you will see the new content in green. Click Commit changes... Click Commit changes... In the \"Commit message\" field, type a short, meaningful commit message that describes the change you made to the file. You can attribute the commit to more than one author in the commit message. For more information, see Creating a commit with multiple authors. In the \"Commit message\" field, type a short, meaningful commit message that describes the change you made to the file. You can attribute the commit to more than one author in the commit message. For more information, see Creating a commit with multiple authors. Below the commit message fields, decide whether to add your commit to the current branch or to a new branch. If your current branch is the default branch, you should choose to create a new branch for your commit and then create a pull request. For more information, see Creating a pull request. Below the commit message fields, decide whether to add your commit to the current branch or to a new branch. If your current branch is the default branch, you should choose to create a new branch for your commit and then create a pull request. For more information, see Creating a pull request. Click Commit changes or Propose changes. Click Commit changes or Propose changes. Now that you have created a project, you can start committing changes. README files are a great place to describe your project in more detail, or add some documentation such as how to install or use your project. The contents of your README file are automatically shown on the front page of your repository. Follow these steps to add a README file. In the command line, navigate to the root directory of your new project. (This directory was created when you ran the gh repo create command.) In the command line, navigate to the root directory of your new project. (This directory was created when you ran the gh repo create command.) gh repo create Create a README file with some information about the project. echo \"info about this project\" >> README.md Create a README file with some information about the project. echo \"info about this project\" >> README.md echo \"info about this project\" >> README.md Enter git status. You will see that you have an untracked README.md file. $ git status Untracked files: (use \"git add <file>...\" to include in what will be committed) README.md nothing added to commit but untracked files present (use \"git add\" to track) Enter git status. You will see that you have an untracked README.md file. $ git status Untracked files: (use \"git add <file>...\" to include in what will be committed) README.md nothing added to commit but untracked files present (use \"git add\" to track) $ git status Untracked files: (use \"git add <file>...\" to include in what will be committed) README.md nothing added to commit but untracked files present (use \"git add\" to track) Stage and commit the file. git add README.md && git commit -m \"Add README\" Stage and commit the file. git add README.md && git commit -m \"Add README\" git add README.md && git commit -m \"Add README\" Push the changes to your branch. git push --set-upstream origin HEAD Push the changes to your branch. git push --set-upstream origin HEAD git push --set-upstream origin HEAD You have now created a repository, including a README file, and created your first commit on GitHub. You can now clone a GitHub repository to create a local copy on your computer. From your local repository you can commit, and create a pull request to update the changes in the upstream repository. For more information, see Cloning a repository and Set up Git. Secure your repository using GitHub's available security features. For more information, see Quickstart for securing your repository. Secure your repository using GitHub's available security features. For more information, see Quickstart for securing your repository. You can find interesting projects and repositories on GitHub and make changes to them by creating a fork of the repository. Forking a repository will allow you to make changes to another repository without affecting the original. For more information, see Fork a repository. You can find interesting projects and repositories on GitHub and make changes to them by creating a fork of the repository. Forking a repository will allow you to make changes to another repository without affecting the original. For more information, see Fork a repository. Each repository on GitHub is owned by a person or an organization. You can interact with the people, repositories, and organizations by connecting and following them on GitHub. For more information, see Finding inspiration on GitHub. Each repository on GitHub is owned by a person or an organization. You can interact with the people, repositories, and organizations by connecting and following them on GitHub. For more information, see Finding inspiration on GitHub. GitHub has a great support community where you can ask for help and talk to people from around the world. Join the conversation on GitHub Community. GitHub has a great support community where you can ask for help and talk to people from around the world. Join the conversation on GitHub Community.",
    "url": "https://docs.github.com/en/repositories/creating-and-managing-repositories/quickstart-for-repositories",
    "section": "Repository Management",
    "word_count": 1405
  },
  {
    "title": "Installing Git Large File Storage",
    "content": "## Installing Git Large File Storage In order to use Git LFS, you'll need to download and install a new program that's separate from Git. ## Platform navigation Navigate to git-lfs.com and click Download. Alternatively, you can install Git LFS using a package manager: To use Homebrew, run brew install git-lfs. To use MacPorts, run port install git-lfs. If you install Git LFS with Homebrew or MacPorts, skip to step six. Navigate to git-lfs.com and click Download. Alternatively, you can install Git LFS using a package manager: To use Homebrew, run brew install git-lfs. brew install git-lfs To use MacPorts, run port install git-lfs. port install git-lfs If you install Git LFS with Homebrew or MacPorts, skip to step six. On your computer, locate and unzip the downloaded file. On your computer, locate and unzip the downloaded file. Open TerminalTerminalGit Bash. Open TerminalTerminalGit Bash. Change the current working directory into the folder you downloaded and unzipped. cd ~/Downloads/git-lfs-X.X.X Note The file path you use after cd depends on your operating system, Git LFS version you downloaded, and where you saved the Git LFS download. Change the current working directory into the folder you downloaded and unzipped. cd ~/Downloads/git-lfs-X.X.X cd ~/Downloads/git-lfs-X.X.X The file path you use after cd depends on your operating system, Git LFS version you downloaded, and where you saved the Git LFS download. To install the file, run this command: $ ./install.sh > Git LFS initialized. Note You may have to use sudo ./install.sh to install the file. To install the file, run this command: $ ./install.sh > Git LFS initialized. $ ./install.sh > Git LFS initialized. You may have to use sudo ./install.sh to install the file. sudo ./install.sh Next, make required changes to your global Git config: $ git lfs install > Git LFS initialized. Next, make required changes to your global Git config: $ git lfs install > Git LFS initialized. $ git lfs install > Git LFS initialized. If you don't see a message indicating that git lfs install was successful, please contact us through the GitHub Support portal. Be sure to include the name of your operating system. If you don't see a message indicating that git lfs install was successful, please contact us through the GitHub Support portal. Be sure to include the name of your operating system. git lfs install Navigate to git-lfs.com and click Download. Tip For more information about alternative ways to install Git LFS for Windows, see this Getting started guide. Navigate to git-lfs.com and click Download. For more information about alternative ways to install Git LFS for Windows, see this Getting started guide. On your computer, locate the downloaded file. On your computer, locate the downloaded file. Double click on the file called git-lfs-windows-1.X.X.exe, where 1.X.X is replaced with the Git LFS version you downloaded. When you open this file Windows will run a setup wizard to install Git LFS. Double click on the file called git-lfs-windows-1.X.X.exe, where 1.X.X is replaced with the Git LFS version you downloaded. When you open this file Windows will run a setup wizard to install Git LFS. Open TerminalTerminalGit Bash. As the setup wizard may have modified your system PATH, opening a new session will ensure Git can locate Git LFS. Open TerminalTerminalGit Bash. As the setup wizard may have modified your system PATH, opening a new session will ensure Git can locate Git LFS. Verify that the installation was successful: $ git lfs install > Git LFS initialized. Verify that the installation was successful: $ git lfs install > Git LFS initialized. $ git lfs install > Git LFS initialized. If you don't see a message indicating that git lfs install was successful, please contact us through the GitHub Support portal. Be sure to include the name of your operating system. If you don't see a message indicating that git lfs install was successful, please contact us through the GitHub Support portal. Be sure to include the name of your operating system. git lfs install Navigate to git-lfs.com and click Download. Tip For more information about alternative ways to install Git LFS for Linux, see this Getting started guide. Navigate to git-lfs.com and click Download. For more information about alternative ways to install Git LFS for Linux, see this Getting started guide. On your computer, locate and unzip the downloaded file. On your computer, locate and unzip the downloaded file. Open TerminalTerminalGit Bash. Open TerminalTerminalGit Bash. Change the current working directory into the folder you downloaded and unzipped. cd ~/Downloads/git-lfs-1.X.X Note The file path you use after cd depends on your operating system, Git LFS version you downloaded, and where you saved the Git LFS download. Change the current working directory into the folder you downloaded and unzipped. cd ~/Downloads/git-lfs-1.X.X cd ~/Downloads/git-lfs-1.X.X The file path you use after cd depends on your operating system, Git LFS version you downloaded, and where you saved the Git LFS download. To install the file, run this command: $ ./install.sh > Git LFS initialized. Note You may have to use sudo ./install.sh to install the file. To install the file, run this command: $ ./install.sh > Git LFS initialized. $ ./install.sh > Git LFS initialized. You may have to use sudo ./install.sh to install the file. sudo ./install.sh Next, make required changes to your global Git config: $ git lfs install > Git LFS initialized. Next, make required changes to your global Git config: $ git lfs install > Git LFS initialized. $ git lfs install > Git LFS initialized. If you don't see a message indicating that git lfs install was successful, please contact us through the GitHub Support portal. Be sure to include the name of your operating system. If you don't see a message indicating that git lfs install was successful, please contact us through the GitHub Support portal. Be sure to include the name of your operating system. git lfs install ## Further reading Configuring Git Large File Storage",
    "url": "https://docs.github.com/en/repositories/working-with-files/managing-large-files/installing-git-large-file-storage",
    "section": "Repository Management",
    "word_count": 989
  },
  {
    "title": "Configuring commit merging for pull requests",
    "content": "## Configuring commit merging for pull requests You can enforce, allow, or disable merging with a merge commit for all pull request merges on GitHub.com in your repository. You can configure pull request merge options to meet your workflow needs and preferences for managing Git history. For more information, see Configuring pull request merges. On GitHub, navigate to the main page of the repository. On GitHub, navigate to the main page of the repository. Under your repository name, click Settings. If you cannot see the \"Settings\" tab, select the dropdown menu, then click Settings. Under your repository name, click Settings. If you cannot see the \"Settings\" tab, select the dropdown menu, then click Settings. Under \"Pull Requests\", select Allow merge commits. This allows contributors to merge a pull request with a full history of commits. Under \"Pull Requests\", select Allow merge commits. This allows contributors to merge a pull request with a full history of commits. Optionally, under Allow merge commits, select the dropdown menu, then click the format of the commit message presented to contributors when merging. The default message includes the pull request number and title. For example, Merge pull request #123 from patch-1. You can also choose to use just the pull request title, or the pull request title and description. Optionally, under Allow merge commits, select the dropdown menu, then click the format of the commit message presented to contributors when merging. The default message includes the pull request number and title. For example, Merge pull request #123 from patch-1. You can also choose to use just the pull request title, or the pull request title and description. Merge pull request #123 from patch-1 If you select more than one merge method, collaborators can choose which type of merge commit to use when they merge a pull request. If there is a protected branch rule in your repository that requires a linear commit history, you must allow squash merging, rebase merging, or both. For more information, see About protected branches. ## Further reading About pull request merges Merging a pull request",
    "url": "https://docs.github.com/en/repositories/configuring-branches-and-merges-in-your-repository/configuring-pull-request-merges/configuring-commit-merging-for-pull-requests",
    "section": "Repository Management",
    "word_count": 345
  },
  {
    "title": "Managing protected branches",
    "content": "## Managing protected branches You can set up rules to protect certain branches in your repository. For example, you can block pull requests that don't pass status checks or require that pull requests have a specific number of approving reviews before they can be merged. ## Who can use this feature? Protected branches are available in public repositories with GitHub Free and GitHub Free for organizations. Protected branches are also available in public and private repositories with GitHub Pro, GitHub Team, GitHub Enterprise Cloud, and GitHub Enterprise Server. For more information, see GitHub’s plans. ## About protected branches You can protect important branches by setting branch protection rules, which define whether collaborators can delete or force push to the branch and set requirements for any pushes to the branch, such as passing status checks or a linear commit history. ## Managing a branch protection rule You can create a branch protection rule to enforce certain workflows for one or more branches, such as requiring an approving review or passing status checks for all pull requests merged into the protected branch.",
    "url": "https://docs.github.com/en/repositories/configuring-branches-and-merges-in-your-repository/managing-protected-branches",
    "section": "Repository Management",
    "word_count": 180
  },
  {
    "title": "Creating rulesets for a repository",
    "content": "## Creating rulesets for a repository You can add rulesets to a repository to control how people can interact with specific branches and tags. ## Who can use this feature? Anyone with read access to a repository can view the repository's rulesets. People with admin access to a repository, or a custom role with the \"edit repository rules\" permission, can create, edit, and delete rulesets for a repository. Rulesets are available in public repositories with GitHub Free and GitHub Free for organizations, and in public and private repositories with GitHub Pro, GitHub Team, and GitHub Enterprise Cloud. For more information, see GitHub’s plans. Push rulesets are available for the GitHub Team plan in internal and private repositories, and forks of repositories that have push rulesets enabled. ## In this article ## Introduction You can create rulesets to control how users can interact with selected branches and tags in a repository. You can control things like who can push commits to a certain branch and how the commits must be formatted, or who can delete or rename a tag. You can also prevent people from renaming repositories. You can also create push rulesets to block pushes to a private or internal repository and the repository's entire fork network. Push rulesets allow you to block pushes based on file extensions, file path lengths, file and folder paths, and file sizes. When you create a ruleset, you can allow certain users to bypass the rules in the ruleset. For more information on rulesets, see About rulesets. For customers on GitHub Team and GitHub Enterprise plans you can also create rulesets for repositories in an organization. For more information, see Creating rulesets for repositories in your organization. ## Importing prebuilt rulesets To import one of the prebuilt rulesets by GitHub, see github/ruleset-recipes. github/ruleset-recipes You can import an existing ruleset using a JSON file. This can be useful if you want to apply the same ruleset to multiple repositories or organizations. For more information, see Managing rulesets for repositories in your organization. ## Using fnmatch syntax You can use fnmatch syntax to define patterns to target when you create a ruleset. You can use the * wildcard to match any string of characters. Because GitHub uses the File::FNM_PATHNAME flag for the File.fnmatch syntax, the * wildcard does not match directory separators (/). For example, qa/* will match all branches beginning with qa/ and containing a single slash, but will not match qa/foo/bar. You can include any number of slashes after qa with qa/**/*, which would match, for example, qa/foo/bar/foobar/hello-world. You can also extend the qa string with qa**/**/* to make the rule more inclusive. File::FNM_PATHNAME File.fnmatch qa/foo/bar/foobar/hello-world For more information about syntax options, see the fnmatch documentation. ## Unsupported fnmatch syntax Not all expressions from the fnmatch syntax are supported in branch protection rules. Please be aware of the following constraints: You cannot use the backslash (\\) character as a quoting character, as GitHub does not support the use of backslashes in branch protection rules. You can specify character sets within square brackets ([]), but you cannot currently complement a set with the ^ operator (e.g., [^charset]). Although GitHub supports File::FNM_PATHNAME in fnmatch syntax, File::FNM_EXTGLOB is not supported. File::FNM_PATHNAME File::FNM_EXTGLOB ## Using ruleset enforcement statuses While creating or editing your ruleset, you can use enforcement statuses to configure how your ruleset will be enforced. You can select any of the following enforcement statuses for your ruleset. Active: your ruleset will be enforced upon creation. Disabled: your ruleset will not be enforced. ## Creating a branch or tag ruleset On GitHub, navigate to the main page of the repository. On GitHub, navigate to the main page of the repository. Under your repository name, click Settings. If you cannot see the \"Settings\" tab, select the dropdown menu, then click Settings. Under your repository name, click Settings. If you cannot see the \"Settings\" tab, select the dropdown menu, then click Settings. In the left sidebar, under \"Code and automation,\" click Rules, then click Rulesets. In the left sidebar, under \"Code and automation,\" click Rules, then click Rulesets. Click New ruleset. Click New ruleset. To create a ruleset targeting branches, click New branch ruleset. Alternatively, to create a ruleset targeting tags, click New tag ruleset. To create a ruleset targeting branches, click New branch ruleset. Alternatively, to create a ruleset targeting tags, click New tag ruleset. Under \"Ruleset name,\" type a name for the ruleset. Under \"Ruleset name,\" type a name for the ruleset. Optionally, to change the default enforcement status, click Disabled and select an enforcement status. For more information about enforcement statuses, see About rulesets. Optionally, to change the default enforcement status, click Disabled and select an enforcement status. For more information about enforcement statuses, see About rulesets. ## Granting bypass permissions for your branch or tag ruleset You can grant certain roles, teams, or apps bypass permissions for your ruleset. The following are eligible for bypass access: Repository admins, organization owners, and enterprise owners The maintain or write role, or custom repository roles based on the write role Teams, excluding secret teams. See About teams. GitHub Apps Dependabot. For more information about Dependabot, see Dependabot quickstart guide. To grant bypass permissions for the ruleset, in the \"Bypass list\" section, click Add bypass. To grant bypass permissions for the ruleset, in the \"Bypass list\" section, click Add bypass. In the \"Add bypass\" modal dialog that appears, search for the role, team, or app you would like to grant bypass permissions, then select the role, team, or app from the \"Suggestions\" section and click Add Selected. In the \"Add bypass\" modal dialog that appears, search for the role, team, or app you would like to grant bypass permissions, then select the role, team, or app from the \"Suggestions\" section and click Add Selected. Optionally, to grant bypass to an actor without allowing them to push directly to a repository, to the right of \"Always allow,\" click , then click For pull requests only. The selected actor is now required to open a pull request to make changes to a repository, creating a clear trail of their changes in the pull request and audit log. The actor can then choose to bypass any branch protections and merge that pull request. Optionally, to grant bypass to an actor without allowing them to push directly to a repository, to the right of \"Always allow,\" click , then click For pull requests only. The selected actor is now required to open a pull request to make changes to a repository, creating a clear trail of their changes in the pull request and audit log. The actor can then choose to bypass any branch protections and merge that pull request. ## Choosing which branches or tags to target To target branches or tags, in the \"Target branches\" or \"Target tags\" section, select Add a target, then select how you want to include or exclude branches or tags. You can use fnmatch syntax to include or exclude branches or tags based on a pattern. For more information, see Using fnmatch syntax. You can add multiple targeting criteria to the same ruleset. For example, you could include the default branch, include any branches matching the pattern *feature*, and then specifically exclude a branch matching the pattern not-a-feature. not-a-feature ## Selecting branch or tag protections In the \"Branch protections\" or \"Tag protections\" section, select the rules you want to include in the ruleset. When you select a rule, you may be able to enter additional settings for the rule. For more information on the rules, see Available rules for rulesets. If you select Require status checks before merging, in the \"Additional settings\" section: You can enter the name of each status check you would like to require. To finish adding the status check as a requirement, you must click . If you select Require branches to be up to date before merging, you must define a check for the protection to take effect. ## Adding metadata restrictions Your metadata restrictions should be intended to increase consistency between commits in your repository. They are not intended to replace security measures such as requiring code review via pull requests. If you squash merge a branch, all commits on that branch must meet any metadata requirements for the base branch. To add a rule to control commit metadata or branch names, in the \"Restrictions\" section when creating or editing a ruleset, click Restrict commit metadata or Restrict branch names. To add a rule to control commit metadata or branch names, in the \"Restrictions\" section when creating or editing a ruleset, click Restrict commit metadata or Restrict branch names. Configure the settings for the restriction, then click Add. You can add multiple restrictions to the same ruleset. Configure the settings for the restriction, then click Add. You can add multiple restrictions to the same ruleset. To match a given regex pattern, in the \"Requirement\" dropdown, select Must match a given regex pattern. For most requirements, such as \"Must start with a matching pattern,\" the pattern you enter is interpreted literally, and wildcards are not supported. For example, the * character only represents the literal * character. For more complex patterns, you can select \"Must match a given regex pattern\" or \"Must not match a given regex pattern,\" then use regular expression syntax to define the matching pattern. For more information, see About regular expressions for commit metadata\" in the GitHub Enterprise Cloud documentation. Anyone who views the rulesets for a repository will be able to see the description you provide. To match a given regex pattern, in the \"Requirement\" dropdown, select Must match a given regex pattern. For most requirements, such as \"Must start with a matching pattern,\" the pattern you enter is interpreted literally, and wildcards are not supported. For example, the * character only represents the literal * character. For more complex patterns, you can select \"Must match a given regex pattern\" or \"Must not match a given regex pattern,\" then use regular expression syntax to define the matching pattern. For more information, see About regular expressions for commit metadata\" in the GitHub Enterprise Cloud documentation. Anyone who views the rulesets for a repository will be able to see the description you provide. Optionally, before enacting your ruleset with metadata restrictions, select the \"Evaluate\" enforcement status for your ruleset to test the effects of any metadata restrictions without impacting contributors. For more information on metadata restrictions, see Available rules for rulesets. Optionally, before enacting your ruleset with metadata restrictions, select the \"Evaluate\" enforcement status for your ruleset to test the effects of any metadata restrictions without impacting contributors. For more information on metadata restrictions, see Available rules for rulesets. ## Finalizing your branch or tag ruleset and next steps To finish creating your ruleset, click Create. If the enforcement status of the ruleset is set to \"Active\", the ruleset takes effect immediately. ## Creating a push ruleset This ruleset will enforce push restrictions for a repository's entire fork network. You can create a push ruleset for private or internal repositories. On GitHub, navigate to the main page of the repository. On GitHub, navigate to the main page of the repository. Under your repository name, click Settings. If you cannot see the \"Settings\" tab, select the dropdown menu, then click Settings. Under your repository name, click Settings. If you cannot see the \"Settings\" tab, select the dropdown menu, then click Settings. In the left sidebar, under \"Code and automation,\" click Rules, then click Rulesets. In the left sidebar, under \"Code and automation,\" click Rules, then click Rulesets. Click New ruleset. Click New ruleset. To create a ruleset targeting branches, click New push ruleset. To create a ruleset targeting branches, click New push ruleset. Under \"Ruleset name,\" type a name for the ruleset. Under \"Ruleset name,\" type a name for the ruleset. Optionally, to change the default enforcement status, click Disabled and select an enforcement status. For more information about enforcement statuses, see About rulesets. Optionally, to change the default enforcement status, click Disabled and select an enforcement status. For more information about enforcement statuses, see About rulesets. ## Granting bypass permissions for your push ruleset Bypass permissions for push rulesets in this repository will be inherited by the entire fork network for this repository. This means that the only users who can bypass this ruleset for any repository in this repository's entire fork network are the users who can bypass this ruleset in the root repository. You can grant certain roles, teams, or apps bypass permissions for your ruleset. The following are eligible for bypass access: Repository admins, organization owners, and enterprise owners The maintain or write role, or custom repository roles based on the write role Teams, excluding secret teams. See About teams. GitHub Apps Dependabot. For more information about Dependabot, see Dependabot quickstart guide. To grant bypass permissions for the ruleset, in the \"Bypass list\" section, click Add bypass. In the \"Add bypass\" modal dialog that appears, search for the role, team, or app you would like to grant bypass permissions, then select the role, team, or app from the \"Suggestions\" section and click Add Selected. ## Selecting push protections You can block pushes to this repository and this repository's entire fork network based on file extensions, file path lengths, file and folder paths, and file sizes. Any push protections you configure will block pushes in this repository and throughout this repository's entire fork network. Under \"Push protections,\" click the restrictions you want to apply. Then fill in the details for the restrictions you select. For file path restrictions, you can use partial or full paths. You can use fnmatch syntax for this. For example, a restriction targeting test/demo/**/* prevents any pushes to files or folders in the test/demo/ directory. A restriction targeting test/docs/pushrules.md prevents pushes specifically to the pushrules.md file in the test/docs/ directory. For more information, see Creating rulesets for a repository. Under \"Push protections,\" click the restrictions you want to apply. Then fill in the details for the restrictions you select. For file path restrictions, you can use partial or full paths. You can use fnmatch syntax for this. For example, a restriction targeting test/demo/**/* prevents any pushes to files or folders in the test/demo/ directory. A restriction targeting test/docs/pushrules.md prevents pushes specifically to the pushrules.md file in the test/docs/ directory. For more information, see Creating rulesets for a repository. test/demo/**/* test/docs/pushrules.md pushrules.md ## Finalizing your push ruleset and next steps To finish creating your ruleset, click Create. If the enforcement status of the ruleset is set to \"Active\", the ruleset takes effect immediately.",
    "url": "https://docs.github.com/en/repositories/configuring-branches-and-merges-in-your-repository/managing-rulesets/creating-rulesets-for-a-repository",
    "section": "Repository Management",
    "word_count": 2430
  },
  {
    "title": "Archiving a GitHub repository",
    "content": "## Archiving a GitHub repository You can archive, back up, and cite your work using the GitHub UI, the API, or third-party tools and services. ## Archiving repositories You can archive a repository to make it read-only for all users and indicate that it's no longer actively maintained. You can also unarchive repositories that have been archived. ## About archiving content and data on GitHub You can archive content and data for other people to view and reference. ## Referencing and citing content You can use third-party tools to cite and reference content on GitHub. ## Backing up a repository You can use Git, a third-party tool, or the API to back up your repository.",
    "url": "https://docs.github.com/en/repositories/archiving-a-github-repository",
    "section": "Repository Management",
    "word_count": 115
  },
  {
    "title": "Troubleshooting cloning errors",
    "content": "## Troubleshooting cloning errors If you're having trouble cloning a repository, check these common errors. ## In this article ## HTTPS cloning errors There are a few common errors when using HTTPS with Git. These errors usually indicate you have an old version of Git, or you don't have access to the repository. Here's an example of an HTTPS error you might receive: > error: The requested URL returned error: 401 while accessing > https://github.com/USER/REPO.git/info/refs?service=git-receive-pack > fatal: HTTP request failed > error: The requested URL returned error: 401 while accessing > https://github.com/USER/REPO.git/info/refs?service=git-receive-pack > fatal: HTTP request failed > Error: The requested URL returned error: 403 while accessing > https://github.com/USER/REPO.git/info/refs > fatal: HTTP request failed > Error: The requested URL returned error: 403 while accessing > https://github.com/USER/REPO.git/info/refs > fatal: HTTP request failed > Error: https://github.com/USER/REPO.git/info/refs not found: did you run git > update-server-info on the server? > Error: https://github.com/USER/REPO.git/info/refs not found: did you run git > update-server-info on the server? ## Check your Git version There's no minimum Git version necessary to interact with GitHub, but we've found version 1.7.10 to be a comfortable stable version that's available on many platforms. You can always download the latest version on the Git website. ## Ensure the remote is correct The repository you're trying to fetch must exist on GitHub.com. You can find the URL of the local repository by opening the command line and typing git remote -v: git remote -v $ git remote -v # View existing remotes > origin https://github.com/ghost/cocoareactive.git (fetch) > origin https://github.com/ghost/cocoareactive.git (push) $ git remote set-url origin https://github.com/ghost/ReactiveCocoa.git # Change the 'origin' remote's URL $ git remote -v # Verify new remote URL > origin https://github.com/ghost/ReactiveCocoa.git (fetch) > origin https://github.com/ghost/ReactiveCocoa.git (push) $ git remote -v # View existing remotes > origin https://github.com/ghost/cocoareactive.git (fetch) > origin https://github.com/ghost/cocoareactive.git (push) $ git remote set-url origin https://github.com/ghost/ReactiveCocoa.git # Change the 'origin' remote's URL $ git remote -v # Verify new remote URL > origin https://github.com/ghost/ReactiveCocoa.git (fetch) > origin https://github.com/ghost/ReactiveCocoa.git (push) Alternatively, you can change the URL through our GitHub Desktop application. ## Provide an access token To access GitHub, you must authenticate with a personal access token instead of your password. For more information, see Managing your personal access tokens. If you are accessing an organization that uses SAML SSO and you are using a personal access token (classic), you must also authorize your personal access token to access the organization before you authenticate. For more information, see About authentication with single sign-on and Authorizing a personal access token for use with single sign-on. ## Check your permissions When prompted for a username and password, make sure you use an account that has access to the repository. If you don't want to enter your credentials every time you interact with the remote repository, you can turn on credential caching. If you are already using credential caching, please make sure that your computer has the correct credentials cached. Incorrect or out of date credentials will cause authentication to fail. ## Use SSH instead If you've previously set up SSH keys, you can use the SSH clone URL instead of HTTPS. For more information, see About remote repositories. ## Error: Repository not found If you see this error when cloning a repository, it means that the repository does not exist or you do not have permission to access it. There are a few solutions to this error, depending on the cause. ## Check your spelling Typos happen. If you try to clone git@github.com:owner/repotile.git, but the repository is really named owner/repoti1e you will receive this error. git@github.com:owner/repotile.git owner/repoti1e To avoid this error, when cloning, always copy and paste the clone URL from the repository's page. For more information, see Cloning a repository. To update the remote on an existing repository, see Managing remote repositories. ## Checking your permissions If you are trying to clone a private repository but do not have permission to view the repository, you will receive this error. Make sure that you have access to the repository in one of these ways: The owner of the repository A collaborator on the repository A member of a team that has access to the repository (if the repository belongs to an organization) ## Check your SSH access In rare circumstances, you may not have the proper SSH access to a repository. You should ensure that the SSH key you are using is attached to your personal account on GitHub. You can check this by typing the following into the command line: $ ssh -T git@github.com > Hi USERNAME! You've successfully authenticated, but GitHub does not > provide shell access. $ ssh -T git@github.com > Hi USERNAME! You've successfully authenticated, but GitHub does not > provide shell access. If the repository belongs to an organization and you're using an SSH key generated by an OAuth app, OAuth app access may have been restricted by an organization owner. For more information, see About OAuth app access restrictions. For more information, see Adding a new SSH key to your GitHub account. ## Check that the repository really exists If all else fails, make sure that the repository really exists on GitHub.com! If you're trying to push to a repository that doesn't exist, you'll get this error. ## Error: Remote HEAD refers to nonexistent ref, unable to checkout This error occurs if the default branch of a repository has been deleted on GitHub.com. Detecting this error is simple; Git will warn you when you try to clone the repository: $ git clone https://github.com/USER/REPO.git # Clone a repo > Cloning into 'repo'... > remote: Counting objects: 66179, done. > remote: Compressing objects: 100% (15587/15587), done. > remote: Total 66179 (delta 46985), reused 65596 (delta 46402) > Receiving objects: 100% (66179/66179), 51.66 MiB | 667 KiB/s, done. > Resolving deltas: 100% (46985/46985), done. > warning: remote HEAD refers to nonexistent ref, unable to checkout. $ git clone https://github.com/USER/REPO.git # Clone a repo > Cloning into 'repo'... > remote: Counting objects: 66179, done. > remote: Compressing objects: 100% (15587/15587), done. > remote: Total 66179 (delta 46985), reused 65596 (delta 46402) > Receiving objects: 100% (66179/66179), 51.66 MiB | 667 KiB/s, done. > Resolving deltas: 100% (46985/46985), done. > warning: remote HEAD refers to nonexistent ref, unable to checkout. To fix the error, you'll need to be an administrator of the repository on GitHub.com. You'll want to change the default branch of the repository. After that, you can get a list of all the available branches from the command line: $ git branch -a # Lists ALL the branches > remotes/origin/awesome > remotes/origin/more-work > remotes/origin/new-main $ git branch -a # Lists ALL the branches > remotes/origin/awesome > remotes/origin/more-work > remotes/origin/new-main Then, you can just switch to your new branch: $ git checkout new-main # Create and checkout a tracking branch > Branch new-main set up to track remote branch new-main from origin. > Switched to a new branch 'new-main' $ git checkout new-main # Create and checkout a tracking branch > Branch new-main set up to track remote branch new-main from origin. > Switched to a new branch 'new-main'",
    "url": "https://docs.github.com/en/repositories/creating-and-managing-repositories/troubleshooting-cloning-errors",
    "section": "Repository Management",
    "word_count": 1178
  },
  {
    "title": "Using query parameters to create a pull request",
    "content": "## Using query parameters to create a pull request Use query parameters to create custom URLs to open pull requests with pre-populated fields. You can use query parameters to open pull requests. Query parameters are optional parts of a URL you can customize to share a specific web page view, such as search filter results or a pull request template on GitHub. To create your own query parameters, you must match the key and value pair. For more information on creating pull request templates, see Creating a pull request template for your repository. You must have the proper permissions for any action to use the equivalent query parameter. For example, you must have permission to add a label to a pull request to use the labels query parameter. For more information, see Repository roles for an organization. If you create an invalid URL using query parameters, or if you don’t have the proper permissions, the URL will return a 404 Not Found error page. If you create a URL that exceeds the server limit, the URL will return a 414 URI Too Long error page. 404 Not Found 414 URI Too Long https://github.com/octo-org/octo-repo/compare/main...my-branch?quick_pull=1 quick_pull=1 https://github.com/octo-org/octo-repo/compare/main...my-branch?quick_pull=1&labels=bug&title=Bug+fix https://github.com/octo-org/octo-repo/compare/main...my-branch?quick_pull=1&title=Bug+fix&body=Describe+the+fix. https://github.com/octo-org/octo-repo/compare/main...my-branch?quick_pull=1&labels=help+wanted,bug https://github.com/octo-org/octo-repo/compare/main...my-branch?quick_pull=1&milestone=testing+milestones https://github.com/octo-org/octo-repo/compare/main...my-branch?quick_pull=1&assignees=octocat https://github.com/octo-org/octo-repo/compare/main...my-branch?quick_pull=1&title=Bug+fix&projects=octo-org/1 https://github.com/octo-org/octo-repo/compare/main...my-branch?quick_pull=1&template=issue_template.md PULL_REQUEST_TEMPLATE",
    "url": "https://docs.github.com/en/pull-requests/collaborating-with-pull-requests/proposing-changes-to-your-work-with-pull-requests/using-query-parameters-to-create-a-pull-request",
    "section": "Pull Requests",
    "word_count": 202
  },
  {
    "title": "Creating and deleting branches within your repository",
    "content": "## Creating and deleting branches within your repository You can create or delete branches directly on GitHub. ## In this article ## Creating a branch You can create a branch in different ways on GitHub. You can only create a branch in a repository to which you have push access. ## Creating a branch via the branches overview On GitHub, navigate to the main page of the repository. On GitHub, navigate to the main page of the repository. From the file tree view on the left, select the branch dropdown menu, then click View all branches. You can also find the branch dropdown menu at the top of the integrated file editor. From the file tree view on the left, select the branch dropdown menu, then click View all branches. You can also find the branch dropdown menu at the top of the integrated file editor. Click New branch. Click New branch. Under \"Branch name\", type a name for the branch. Under \"Branch name\", type a name for the branch. Under \"Branch source\", choose a source for your branch. If your repository is a fork, select the repository dropdown menu and click your fork or the upstream repository. Select the branch dropdown menu and click a branch. Under \"Branch source\", choose a source for your branch. If your repository is a fork, select the repository dropdown menu and click your fork or the upstream repository. Select the branch dropdown menu and click a branch. Click Create branch. Click Create branch. ## Creating a branch using the branch dropdown On GitHub, navigate to the main page of the repository. On GitHub, navigate to the main page of the repository. Select the branch dropdown menu, in the file tree view or at the top of the integrated file editor. Select the branch dropdown menu, in the file tree view or at the top of the integrated file editor. Optionally, if you want to create the new branch from a branch other than the default branch of the repository, click another branch, then select the branch dropdown menu again. Optionally, if you want to create the new branch from a branch other than the default branch of the repository, click another branch, then select the branch dropdown menu again. In the \"Find or create a branch...\" text field, type a unique name for your new branch, then click Create branch. In the \"Find or create a branch...\" text field, type a unique name for your new branch, then click Create branch. ## Creating a branch for an issue You can create a branch to work on an issue directly from the issue page and get started right away. For more information, see Creating a branch to work on an issue. ## Deleting a branch You can have head branches automatically deleted after pull requests are merged in your repository. For more information, see Managing the automatic deletion of branches. If the branch you want to delete is the repository's default branch, you must choose a new default branch before deleting the branch. For more information, see Changing the default branch. If the branch you want to delete is associated with an open pull request, you must merge or close the pull request before deleting the branch. For more information, see Merging a pull request or Closing a pull request. On GitHub, navigate to the main page of the repository. On GitHub, navigate to the main page of the repository. From the file tree view on the left, select the branch dropdown menu, then click View all branches. You can also find the branch dropdown menu at the top of the integrated file editor. From the file tree view on the left, select the branch dropdown menu, then click View all branches. You can also find the branch dropdown menu at the top of the integrated file editor. Next to the branch that you want to delete, click . Next to the branch that you want to delete, click . If the branch is associated with at least one open pull request, deleting the branch will close the pull requests. Read the warning, then click Delete. If the branch is associated with at least one open pull request, deleting the branch will close the pull requests. Read the warning, then click Delete. If you delete a head branch after its pull request has been merged, GitHub checks for any open pull requests in the same repository that specify the deleted branch as their base branch. GitHub automatically updates any such pull requests, changing their base branch to the merged pull request's base branch. For more information, see About branches. ## Further reading About branches Viewing branches in your repository Deleting and restoring branches in a pull request",
    "url": "https://docs.github.com/en/pull-requests/collaborating-with-pull-requests/proposing-changes-to-your-work-with-pull-requests/creating-and-deleting-branches-within-your-repository",
    "section": "Pull Requests",
    "word_count": 793
  },
  {
    "title": "Managing and standardizing pull requests",
    "content": "## Managing and standardizing pull requests Use these steps to manage and standardize the pull requests that contributors create in your repository. ## In this article If you are a repository maintainer, there are several ways that you can manage and standardize the pull requests that contributors create in your repository. These steps can help you ensure that pull requests are reviewed by the right people, and that they meet your repository's standards. ## Using pull request templates Pull request templates let you customize and standardize the information you'd like to be included when someone creates a pull request in your repository. When you add a pull request template to your repository, project contributors will automatically see the template's contents in the pull request body. For more information, see Creating a pull request template for your repository. You can use pull request templates to standardize the review process for your repository. For example, you can include a list of tasks that you would like authors to complete before merging their pull requests, by adding a task list to the template. For more information, see About tasklists. You can request that contributors include an issue reference in their pull request body, so that merging the pull request will automatically close the issue. For more information, see Linking a pull request to an issue. ## Defining code owners You may want to make sure that specific individuals always review changes to certain code or files in your repository. For example, you may want to ensure that a member of the security team always reviews changes to your SECURITY.md file or dependabot.yml file. SECURITY.md dependabot.yml You can define individuals or teams that you consider responsible for code or files in a repository to be code owners. Code owners will automatically be requested for review when someone opens a pull request that modifies the files that they own. You can define code owners for specific types of files or directories, as well as for different branches in a repository. For more information, see About code owners. ## Using protected branches You can use protected branches to prevent pull requests from being merged into important branches, such as main, until certain conditions are met. For example, you can require an approving review, or require that all status checks are passing. See About protected branches. ## Using rulesets Working alongside protected branches, rulesets let you enforce policies across your repository, such as requiring status checks or workflows to pass before a pull request can be merged. Rulesets are especially useful for maintaining repository security when combined with other automated security checks. For example: You can use rulesets to enforce the dependency review action, a workflow that blocks pull requests that are introducing vulnerable dependencies into your codebase. See Enforcing dependency review across an organization. If your repository is configured with code scanning, you can use rulesets to set code scanning merge protection, which prevents pull requests from being merged if there is a code scanning alert of a certain severity, or if a code scanning analysis is still in progress. See Set code scanning merge protection. ## Using push rulesets With push rulesets, you can block pushes to a private or internal repository and that repository's entire fork network based on file extensions, file path lengths, file and folder paths, and file sizes. Push rules do not require any branch targeting because they apply to every push to the repository. Push rulesets allow you to: Restrict file paths: Prevent commits that include changes in specified file paths from being pushed. You can use fnmatch syntax for this. For example, a restriction targeting test/demo/**/* prevents any pushes to files or folders in the test/demo/ directory. A restriction targeting test/docs/pushrules.md prevents pushes specifically to the pushrules.md file in the test/docs/ directory. For more information, see Creating rulesets for a repository. Restrict file paths: Prevent commits that include changes in specified file paths from being pushed. You can use fnmatch syntax for this. For example, a restriction targeting test/demo/**/* prevents any pushes to files or folders in the test/demo/ directory. A restriction targeting test/docs/pushrules.md prevents pushes specifically to the pushrules.md file in the test/docs/ directory. For more information, see Creating rulesets for a repository. test/demo/**/* test/docs/pushrules.md pushrules.md Restrict file path length: Prevent commits that include file paths that exceed a specified character limit from being pushed. Restrict file path length: Prevent commits that include file paths that exceed a specified character limit from being pushed. Restrict file extensions: Prevent commits that include files with specified file extensions from being pushed. Restrict file extensions: Prevent commits that include files with specified file extensions from being pushed. Restrict file size: Prevent commits that exceed a specified file size limit from being pushed. Restrict file size: Prevent commits that exceed a specified file size limit from being pushed. ## About push rulesets for forked repositories Push rules apply to the entire fork network for a repository, ensuring every entry point to the repository is protected. For example, if you fork a repository that has push rulesets enabled, the same push rulesets will also apply to your forked repository. For a forked repository, the only people who have bypass permissions for a push rule are the people who have bypass permissions in the root repository. For more information, see About rulesets. ## Using automated tools to review code styling Use automated tools, such as linters, in your repository's pull requests to maintain consistent styling and make code more understandable. Using automated tools to catch smaller problems like typos or styling leaves more time for reviewers to focus on the substance of a pull request. For example, you can use GitHub Actions to set up code linters that can run on pull requests as part of your continuous integration (CI) workflow. For more information, see Continuous integration.",
    "url": "https://docs.github.com/en/pull-requests/collaborating-with-pull-requests/getting-started/managing-and-standardizing-pull-requests",
    "section": "Pull Requests",
    "word_count": 973
  },
  {
    "title": "About commits",
    "content": "## About commits You can save small groups of meaningful changes as commits. ## In this article ## About commits Similar to saving a file that's been edited, a commit records changes to one or more files in your branch. Git assigns each commit a unique ID, called a SHA or hash, that identifies: The specific changes When the changes were made Who created the changes When you make a commit, you must include a commit message that briefly describes the changes. If the repository you are committing to has compulsory commit signoffs enabled, and you are committing via the web interface, you will automatically sign off on the commit as part of the commit process. For more information, see Managing the commit signoff policy for your repository. You can add a co-author on any commits you collaborate on. For more information, see Creating a commit with multiple authors. You can also create a commit on behalf of an organization. For more information, see Creating a commit on behalf of an organization. Rebasing allows you to change a series of commits and can modify the order of the commits in your timeline. For more information, see About Git rebase. ## About commit branches and tag labels You can see which branch a commit is on by looking at the labels beneath the commit on the commit page. On GitHub, navigate to the main page of the repository. On GitHub, navigate to the main page of the repository. On the main page of the repository, above the file list, click commits. On the main page of the repository, above the file list, click commits. To navigate to a specific commit, click the commit message for that commit. To navigate to a specific commit, click the commit message for that commit. To see what branch the commit is on, check the label below the commit message. To see what branch the commit is on, check the label below the commit message. If your commit is not on the default branch (main), the label will show the branches which contain the commit. If the commit is part of an unmerged pull request, you can click the link to go to the pull request. Once the commit is on the default branch, any tags that contain the commit will be shown and the default branch will be the only branch listed. For more information on tags, see Git Basics - Tagging in the Git documentation. ## Using the file tree You can use the file tree to navigate between files in a commit. On GitHub, navigate to the main page of the repository. On GitHub, navigate to the main page of the repository. On the main page of the repository, above the file list, click commits. On the main page of the repository, above the file list, click commits. To navigate to a specific commit, click the commit message for that commit. To navigate to a specific commit, click the commit message for that commit. Click on a file in the file tree to view the corresponding file diff. If the file tree is hidden, click to display the file tree. Note The file tree will not display if your screen width is too narrow or if the commit only includes one file. Click on a file in the file tree to view the corresponding file diff. If the file tree is hidden, click to display the file tree. The file tree will not display if your screen width is too narrow or if the commit only includes one file. To filter by file path, enter part or all of the file path in the Filter changed files search box. To filter by file path, enter part or all of the file path in the Filter changed files search box. ## Further reading Committing and reviewing changes to your project in GitHub Desktop on GitHub Desktop",
    "url": "https://docs.github.com/en/pull-requests/committing-changes-to-your-project/creating-and-editing-commits/about-commits",
    "section": "Pull Requests",
    "word_count": 652
  },
  {
    "title": "Incorporating feedback in your pull request",
    "content": "## Incorporating feedback in your pull request When reviewers suggest changes in a pull request, you can automatically incorporate the changes into the pull request or open an issue to track out-of-scope suggestions. ## In this article ## Applying suggested changes Other people can suggest specific changes to your pull request. You can apply these suggested changes directly in a pull request if you have write access to the repository. If the pull request was created from a fork and the author allowed edits from maintainers, you can also apply suggested changes if you have write access to the upstream repository. For more information, see Commenting on a pull request and Allowing changes to a pull request branch created from a fork. To quickly incorporate more than one suggested change into a single commit, you can also apply suggested changes as a batch. Applying one suggested change or a batch of suggested changes creates a single commit on the compare branch of the pull request. Each person who suggested a change included in the commit will be a co-author of the commit. The person who applies the suggested changes will be a co-author and the committer of the commit. For more information about the term committer in Git, see Git Basics - Viewing the Commit History from the Pro Git book site. Under your repository name, click Pull requests. Under your repository name, click Pull requests. In the list of pull requests, click the pull request you'd like to apply a suggested change to. In the list of pull requests, click the pull request you'd like to apply a suggested change to. Navigate to the first suggested change you'd like to apply. To apply the change in its own commit, click Commit suggestion. To add the suggestion to a batch of changes, click Add suggestion to batch. Continue to add the suggested changes you want to include in a single commit. When you've finished adding suggested changes, click Commit suggestions. Navigate to the first suggested change you'd like to apply. To apply the change in its own commit, click Commit suggestion. To apply the change in its own commit, click Commit suggestion. To add the suggestion to a batch of changes, click Add suggestion to batch. Continue to add the suggested changes you want to include in a single commit. When you've finished adding suggested changes, click Commit suggestions. To add the suggestion to a batch of changes, click Add suggestion to batch. Continue to add the suggested changes you want to include in a single commit. When you've finished adding suggested changes, click Commit suggestions. In the commit message field, type a short, meaningful commit message that describes the change you made to the file or files. In the commit message field, type a short, meaningful commit message that describes the change you made to the file or files. Click Commit changes. Click Commit changes. ## Re-requesting a review You can re-request a review, for example, after you've made substantial changes to your pull request. To request a fresh review from a reviewer, in the sidebar of the Conversation tab, click the icon. ## Opening an issue for an out-of-scope suggestion If someone suggests changes to your pull request and the changes are out of the pull request's scope, you can open a new issue to track the feedback. For more information, see Creating an issue. ## Further reading About pull request reviews Reviewing proposed changes in a pull request Commenting on a pull request Requesting a pull request review Creating an issue",
    "url": "https://docs.github.com/en/pull-requests/collaborating-with-pull-requests/reviewing-changes-in-pull-requests/incorporating-feedback-in-your-pull-request",
    "section": "Pull Requests",
    "word_count": 594
  },
  {
    "title": "Reviewing dependency changes in a pull request",
    "content": "## Reviewing dependency changes in a pull request If a pull request contains changes to dependencies, you can view a summary of what has changed and whether there are known vulnerabilities in any of the dependencies. ## Who can use this feature? Dependency review is available for the following repository types: Public repositories on GitHub.com Organization-owned repositories on GitHub Team with GitHub Code Security enabled ## In this article ## About dependency review Dependency review helps you understand dependency changes and the security impact of these changes at every pull request. It provides an easily understandable visualization of dependency changes with a rich diff on the \"Files Changed\" tab of a pull request. Dependency review informs you of: Which dependencies were added, removed, or updated, along with the release dates How many projects use these components Vulnerability data for these dependencies Dependency review allows you to \"shift left\". You can use the provided predictive information to catch vulnerable dependencies before they hit production. For more information, see About dependency review. You can use the dependency review action to help enforce dependency reviews on pull requests in your repository. The dependency review action scans your pull requests for dependency changes and raises an error if any new dependencies have known vulnerabilities. The action is supported by an API endpoint that compares the dependencies between two revisions and reports any differences. For more information about the action and the API endpoint, see the dependency-review-action documentation, and REST API endpoints for dependency review. dependency-review-action You can configure the dependency review action to better suit your needs by specifying the type of dependency vulnerability you wish to catch. For more information, see Configuring the dependency review action. ## Reviewing dependencies in a pull request Under your repository name, click Pull requests. Under your repository name, click Pull requests. In the list of pull requests, click the pull request you'd like to review. In the list of pull requests, click the pull request you'd like to review. On the pull request, click Files changed. On the pull request, click Files changed. If the pull request contains many files, use the File filter drop-down menu to collapse all files that don't record dependencies. This will make it easier to focus your review on the dependency changes. The dependency review provides a clearer view of what has changed in large lock files, where the source diff is not rendered by default. Note Dependency review rich diffs are not available for committed static JavaScript files like jquery.js. If the pull request contains many files, use the File filter drop-down menu to collapse all files that don't record dependencies. This will make it easier to focus your review on the dependency changes. The dependency review provides a clearer view of what has changed in large lock files, where the source diff is not rendered by default. Dependency review rich diffs are not available for committed static JavaScript files like jquery.js. On the right of the header for a manifest or lock file, display the dependency review by clicking . On the right of the header for a manifest or lock file, display the dependency review by clicking . Check the dependencies listed in the dependency review. Any added or changed dependencies that have vulnerabilities are listed first, ordered by severity and then by dependency name. This means that the highest severity dependencies are always at the top of a dependency review. Other dependencies are listed alphabetically by dependency name. The icon beside each dependency indicates whether the dependency has been added (), updated (), or removed () in this pull request. Other information includes: The version, or version range, of the new, updated, or deleted dependency. For a specific version of a dependency: The age of that release of the dependency. The number of projects that are dependent on this software. This information is taken from the dependency graph. Checking the number of dependents can help you avoid accidentally adding the wrong dependency. The license used by this dependency, if this information is available. This is useful if you want to avoid code with certain licenses being used in your project. Where a dependency has a known vulnerability, the warning message includes: A brief description of the vulnerability. A Common Vulnerabilities and Exposures (CVE) or GitHub Security Advisories (GHSA) identification number. You can click this ID to find out more about the vulnerability. The severity of the vulnerability. The version of the dependency in which the vulnerability was fixed. If you are reviewing a pull request for someone, you might ask the contributor to update the dependency to the patched version, or a later release. Check the dependencies listed in the dependency review. Any added or changed dependencies that have vulnerabilities are listed first, ordered by severity and then by dependency name. This means that the highest severity dependencies are always at the top of a dependency review. Other dependencies are listed alphabetically by dependency name. The icon beside each dependency indicates whether the dependency has been added (), updated (), or removed () in this pull request. Other information includes: The version, or version range, of the new, updated, or deleted dependency. For a specific version of a dependency: The age of that release of the dependency. The number of projects that are dependent on this software. This information is taken from the dependency graph. Checking the number of dependents can help you avoid accidentally adding the wrong dependency. The license used by this dependency, if this information is available. This is useful if you want to avoid code with certain licenses being used in your project. The age of that release of the dependency. The number of projects that are dependent on this software. This information is taken from the dependency graph. Checking the number of dependents can help you avoid accidentally adding the wrong dependency. The license used by this dependency, if this information is available. This is useful if you want to avoid code with certain licenses being used in your project. Where a dependency has a known vulnerability, the warning message includes: A brief description of the vulnerability. A Common Vulnerabilities and Exposures (CVE) or GitHub Security Advisories (GHSA) identification number. You can click this ID to find out more about the vulnerability. The severity of the vulnerability. The version of the dependency in which the vulnerability was fixed. If you are reviewing a pull request for someone, you might ask the contributor to update the dependency to the patched version, or a later release. You may also want to review the source diff, because there could be changes to the manifest or lock file that don't change dependencies, or there could be dependencies that GitHub can't parse and which, as a result, don't appear in the dependency review. To return to the source diff view, click the button. You may also want to review the source diff, because there could be changes to the manifest or lock file that don't change dependencies, or there could be dependencies that GitHub can't parse and which, as a result, don't appear in the dependency review. To return to the source diff view, click the button.",
    "url": "https://docs.github.com/en/pull-requests/collaborating-with-pull-requests/reviewing-changes-in-pull-requests/reviewing-dependency-changes-in-a-pull-request",
    "section": "Pull Requests",
    "word_count": 1199
  },
  {
    "title": "Merging a pull request with a merge queue",
    "content": "## Merging a pull request with a merge queue If a merge queue is required by the branch protection setting for the branch, you can add your pull requests to a merge queue and GitHub will merge the pull requests for you once all required checks have passed. ## Who can use this feature? Pull request merge queues are available in any public repository owned by an organization, or in private repositories owned by organizations using GitHub Enterprise Cloud. For more information, see GitHub’s plans. ## Tool navigation ## In this article ## About merge queues A merge queue helps increase velocity by automating pull request merges into a busy branch and ensuring the branch is never broken by incompatible changes. The merge queue provides the same benefits as the Require branches to be up to date before merging branch protection, but does not require a pull request author to update their pull request branch and wait for status checks to finish before trying to merge. Using a merge queue is particularly useful on branches that have a relatively high number of pull requests merging each day from many different users. Once a pull request has passed all required branch protection checks, a user with write access to the repository can add the pull request to the queue. The merge queue will ensure the pull request's changes pass all required status checks when applied to the latest version of the target branch and any pull requests already in the queue. A merge queue may use GitHub Actions or your own CI provider to run required checks on pull requests in a merge queue. For more information, see GitHub Actions documentation. For more information about merge queues, see Managing a merge queue. ## Adding a pull request to a merge queue You can use GitHub CLI to add a pull request to a merge queue. For more information, click the \"GitHub CLI\" tab at the top of this article. On GitHub, navigate to the main page of the repository. On GitHub, navigate to the main page of the repository. Under your repository name, click Pull requests. Under your repository name, click Pull requests. In the \"Pull Requests\" list, click the pull request you would like to add to a merge queue. In the \"Pull Requests\" list, click the pull request you would like to add to a merge queue. Click Merge when ready to add the pull request to the merge queue. Alternatively, if you are an administrator, you can: Directly merge the pull request by checking Merge without waiting for requirements to be met (bypass branch protections), if allowed by branch protection settings, and follow the standard flow. Note You can click Merge when ready whenever you're ready to merge your proposed changes. GitHub will automatically add the pull request to the merge queue once required approval and status checks conditions are met. Click Merge when ready to add the pull request to the merge queue. Alternatively, if you are an administrator, you can: Directly merge the pull request by checking Merge without waiting for requirements to be met (bypass branch protections), if allowed by branch protection settings, and follow the standard flow. You can click Merge when ready whenever you're ready to merge your proposed changes. GitHub will automatically add the pull request to the merge queue once required approval and status checks conditions are met. Confirm you want to add the pull request to the merge queue by clicking Confirm merge when ready. Confirm you want to add the pull request to the merge queue by clicking Confirm merge when ready. With GitHub CLI, you can use the gh pr merge command to add a pull request to a merge queue. If you are targeting a branch that requires a merge queue, this command automatically adds the pull request to the queue if required checks have passed. If required checks have not passed, this command enables auto-merge for the pull request. For more information, see gh pr merge in the GitHub CLI manual. gh pr merge gh pr merge ## Removing a pull request from a merge queue To remove a pull request from a merge queue, you must navigate to the repository's page on GitHub.com. You cannot use GitHub CLI to remove a pull request from a merge queue. On GitHub, navigate to the main page of the repository. On GitHub, navigate to the main page of the repository. Under your repository name, click Pull requests. Under your repository name, click Pull requests. In the \"Pull Requests\" list, click the pull request you would like to remove from a merge queue. In the \"Pull Requests\" list, click the pull request you would like to remove from a merge queue. To remove the pull request from the queue, click Remove from queue. To remove the pull request from the queue, click Remove from queue. Alternatively, you can navigate to the merge queue page for the base branch, click ... next to the pull request you want to remove, and select Remove from queue. For information on how to get to the merge queue page for the base branch, see the section below. ## Viewing merge queues You can view the merge queue for a base branch in various places on GitHub. You cannot use GitHub CLI to view a merge queue. You can view the merge queue for a base branch in various places on GitHub. On the Branches page for the repository. We recommend you use this route if you don't have or don't know about a pull request already in a queue, and if you want to see what's in that queue. For more information, see Viewing branches in your repository. On the Branches page for the repository. We recommend you use this route if you don't have or don't know about a pull request already in a queue, and if you want to see what's in that queue. For more information, see Viewing branches in your repository. On the pull request page when merge queue is required for merging, scroll to the bottom of the timeline and click the merge queue link. On the pull request page when merge queue is required for merging, scroll to the bottom of the timeline and click the merge queue link. The merge queue view shows the pull requests that are currently in the queue, with your pull requests clearly marked. The merge queue view shows the pull requests that are currently in the queue, with your pull requests clearly marked. ## Understanding why your pull request was removed from the merge queue After grouping a pull request with the latest version of the target branch and changes ahead of it in the queue, if there are failed required status checks or conflicts with the base branch, the pull request will be removed from the queue. The pull request timeline will display the reason why the pull request was removed from the queue. There are a number of reasons a pull request can be removed from a merge queue: Configured CI service is reporting test failures for a merge group Timed out awaiting a successful CI result based off the configured timeout setting User requesting a removal via the API or merge queue interface Branch protection failure that could not automatically be resolved",
    "url": "https://docs.github.com/en/pull-requests/collaborating-with-pull-requests/incorporating-changes-from-a-pull-request/merging-a-pull-request-with-a-merge-queue",
    "section": "Pull Requests",
    "word_count": 1224
  },
  {
    "title": "Comparing commits",
    "content": "## Comparing commits You can compare the state of your repository across branches, tags, commits, forks, and dates. ## In this article To compare different versions of your repository, append /compare to your repository's path. We'll demonstrate the power of Compare by looking at the compare page for a fork of the Linguist repo, which is at https://github.com/octocat/linguist/compare/master...octocat:master. Every repository's Compare view contains two drop down menus: base and compare. base should be considered the starting point of your comparison, and compare is the endpoint. During a comparison, you can always change your base and compare points by clicking on Edit. ## Comparing branches The most common use of Compare is to compare branches, such as when you're starting a new pull request. You'll always be taken to the branch comparison view when starting a new pull request. To compare branches, you can select a branch name from the compare drop down menu at the top of the page. Here's an example of a comparison between two branches. ## Comparing tags Comparing release tags will show you changes to your repository since the last release. For more information, see Comparing releases. To compare tags, you can select a tag name from the compare drop-down menu at the top of the page. Here's an example of a comparison between two tags. If a branch and a tag have the same name, the branch will be used when comparing commits. You can compare the tag specifically by adding tags/ to the tag name. ## Comparing commits You can also compare two arbitrary commits in your repository or its forks on GitHub in a two-dot diff comparison. To quickly compare two commits or Git Object IDs (OIDs) directly with each other in a two-dot diff comparison on GitHub, edit the URL of your repository's \"Comparing changes\" page. For example, this URL uses the shortened SHA codes to compare commits f75c570 and 3391dcc: https://github.com/github-linguist/linguist/compare/f75c570..3391dcc. https://github.com/github-linguist/linguist/compare/f75c570..3391dcc To learn more about other comparison options, see About comparing branches in pull requests. ## Comparing across forks You can compare your base repository and any forked repository. This is the view that's presented when a user performs a Pull Request to a project. To compare branches on different repositories, preface the branch names with user names. For example, by specifying octocat:main for base and octo-org:main for compare, you can compare the main branch of the repositories respectively owned by octocat and octo-org. octocat:main octo-org:main You can also preface the branch name with a user name and a repository name. For example, specifying octocat:awesome-app:main would use the main branch in the octocat/awesome-app repository. This can be useful in large organizations, where you might have an upstream repository and a fork both owned by the organization. For more information, see About forks. octocat:awesome-app:main octocat/awesome-app Here's an example of a comparison between two repositories. ## Comparisons across commits You can compare a single commit in Git to the commit's predecessors using two types of notation. 96d29b7^^^^^ ## Further reading Changing the base branch of a pull request",
    "url": "https://docs.github.com/en/pull-requests/committing-changes-to-your-project/viewing-and-comparing-commits/comparing-commits",
    "section": "Pull Requests",
    "word_count": 506
  },
  {
    "title": "Syncing a fork",
    "content": "## Syncing a fork Sync a fork of a repository to keep it up-to-date with the upstream repository. ## Who can use this feature? People with write access for a forked repository can sync the fork to the upstream repository. ## Platform navigation ## In this article ## Syncing a fork branch from the web UI On GitHub, navigate to the main page of the forked repository that you want to sync with the upstream repository. On GitHub, navigate to the main page of the forked repository that you want to sync with the upstream repository. Above the list of files, select the Sync fork dropdown menu. Above the list of files, select the Sync fork dropdown menu. Review the details about the commits from the upstream repository, then click Update branch. Review the details about the commits from the upstream repository, then click Update branch. If the changes from the upstream repository cause conflicts, GitHub will prompt you to create a pull request to resolve the conflicts. ## Syncing a fork branch with the GitHub CLI GitHub CLI is an open source tool for using GitHub from your computer's command line. When you're working from the command line, you can use the GitHub CLI to save time and avoid switching context. To learn more about GitHub CLI, see About GitHub CLI. To update the remote fork from its parent, use the gh repo sync -b BRANCH-NAME subcommand and supply your fork and branch name as arguments. gh repo sync -b BRANCH-NAME gh repo sync owner/cli-fork -b BRANCH-NAME gh repo sync owner/cli-fork -b BRANCH-NAME If the changes from the upstream repository cause conflict then the GitHub CLI can't sync. You can set the --force flag to overwrite the destination branch. ## Syncing a fork branch from the command line Before you can sync your fork with an upstream repository, you must configure a remote that points to the upstream repository in Git. For more information, see Configuring a remote repository for a fork. Open TerminalTerminalGit Bash. Open TerminalTerminalGit Bash. Change the current working directory to your local project. Change the current working directory to your local project. Fetch the branches and their respective commits from the upstream repository. Commits to BRANCH-NAME will be stored in the local branch upstream/BRANCH-NAME. $ git fetch upstream > remote: Counting objects: 75, done. > remote: Compressing objects: 100% (53/53), done. > remote: Total 62 (delta 27), reused 44 (delta 9) > Unpacking objects: 100% (62/62), done. > From https://github.com/ORIGINAL-OWNER/ORIGINAL-REPOSITORY > * [new branch] main -> upstream/main Fetch the branches and their respective commits from the upstream repository. Commits to BRANCH-NAME will be stored in the local branch upstream/BRANCH-NAME. BRANCH-NAME upstream/BRANCH-NAME $ git fetch upstream > remote: Counting objects: 75, done. > remote: Compressing objects: 100% (53/53), done. > remote: Total 62 (delta 27), reused 44 (delta 9) > Unpacking objects: 100% (62/62), done. > From https://github.com/ORIGINAL-OWNER/ORIGINAL-REPOSITORY > * [new branch] main -> upstream/main $ git fetch upstream > remote: Counting objects: 75, done. > remote: Compressing objects: 100% (53/53), done. > remote: Total 62 (delta 27), reused 44 (delta 9) > Unpacking objects: 100% (62/62), done. > From https://github.com/ORIGINAL-OWNER/ORIGINAL-REPOSITORY > * [new branch] main -> upstream/main Check out your fork's local default branch - in this case, we use main. $ git checkout main > Switched to branch 'main' Check out your fork's local default branch - in this case, we use main. $ git checkout main > Switched to branch 'main' $ git checkout main > Switched to branch 'main' Merge the changes from the upstream default branch - in this case, upstream/main - into your local default branch. This brings your fork's default branch into sync with the upstream repository, without losing your local changes. $ git merge upstream/main > Updating a422352..5fdff0f > Fast-forward > README | 9 ------- > README.md | 7 ++++++ > 2 files changed, 7 insertions(+), 9 deletions(-) > delete mode 100644 README > create mode 100644 README.md If your local branch didn't have any unique commits, Git will perform a fast-forward. For more information, see Basic Branching and Merging in the Git documentation. $ git merge upstream/main > Updating 34e91da..16c56ad > Fast-forward > README.md | 5 +++-- > 1 file changed, 3 insertions(+), 2 deletions(-) If your local branch had unique commits, you may need to resolve conflicts. For more information, see Addressing merge conflicts. Merge the changes from the upstream default branch - in this case, upstream/main - into your local default branch. This brings your fork's default branch into sync with the upstream repository, without losing your local changes. upstream/main $ git merge upstream/main > Updating a422352..5fdff0f > Fast-forward > README | 9 ------- > README.md | 7 ++++++ > 2 files changed, 7 insertions(+), 9 deletions(-) > delete mode 100644 README > create mode 100644 README.md $ git merge upstream/main > Updating a422352..5fdff0f > Fast-forward > README | 9 ------- > README.md | 7 ++++++ > 2 files changed, 7 insertions(+), 9 deletions(-) > delete mode 100644 README > create mode 100644 README.md If your local branch didn't have any unique commits, Git will perform a fast-forward. For more information, see Basic Branching and Merging in the Git documentation. $ git merge upstream/main > Updating 34e91da..16c56ad > Fast-forward > README.md | 5 +++-- > 1 file changed, 3 insertions(+), 2 deletions(-) $ git merge upstream/main > Updating 34e91da..16c56ad > Fast-forward > README.md | 5 +++-- > 1 file changed, 3 insertions(+), 2 deletions(-) If your local branch had unique commits, you may need to resolve conflicts. For more information, see Addressing merge conflicts. Syncing your fork only updates your local copy of the repository. To update your fork on GitHub.com, you must push your changes.",
    "url": "https://docs.github.com/en/pull-requests/collaborating-with-pull-requests/working-with-forks/syncing-a-fork",
    "section": "Pull Requests",
    "word_count": 951
  },
  {
    "title": "Changing the stage of a pull request",
    "content": "## Changing the stage of a pull request You can mark a draft pull request as ready for review or convert a pull request to a draft. ## Who can use this feature? People with write permissions to a repository and pull request authors can change the stage of a pull request. ## In this article ## Marking a pull request as ready for review When you're ready to get feedback on your pull request, you can mark your draft pull request as ready for review. Marking a pull request as ready for review will request reviews from any code owners. You can also mark a pull request as ready for review using the GitHub CLI. For more information, see gh pr ready in the GitHub CLI documentation. gh pr ready Under your repository name, click Pull requests. Under your repository name, click Pull requests. In the \"Pull requests\" list, click the pull request you'd like to mark as ready for review. In the \"Pull requests\" list, click the pull request you'd like to mark as ready for review. In the merge box, click Ready for review. In the merge box, click Ready for review. ## Converting a pull request to a draft You can convert a pull request to a draft at any time. For example, if you accidentally opened a pull request instead of a draft, or if you've received feedback on your pull request that needs to be addressed, you can convert the pull request to a draft to indicate further changes are needed. No one can merge the pull request until you mark the pull request as ready for review again. People who are already subscribed to notifications for the pull request will not be unsubscribed when you convert the pull request to a draft. Under your repository name, click Pull requests. Under your repository name, click Pull requests. In the \"Pull requests\" list, click the pull request you'd like to convert to a draft. In the \"Pull requests\" list, click the pull request you'd like to convert to a draft. In the right sidebar, under \"Reviewers,\" click Convert to draft. In the right sidebar, under \"Reviewers,\" click Convert to draft. Click Convert to draft. Click Convert to draft. ## Further reading About pull requests",
    "url": "https://docs.github.com/en/pull-requests/collaborating-with-pull-requests/proposing-changes-to-your-work-with-pull-requests/changing-the-stage-of-a-pull-request",
    "section": "Pull Requests",
    "word_count": 379
  },
  {
    "title": "About pull request merges",
    "content": "## About pull request merges You can merge pull requests by retaining all the commits in a feature branch, squashing all commits into a single commit, or by rebasing individual commits from the head branch onto the base branch. ## In this article ## Merge your commits When you click the default Merge pull request option on a pull request, all commits from the feature branch are added to the base branch in a merge commit. The pull request is merged using the --no-ff option. To merge pull requests, you must have write permissions in the repository. ## Squash and merge your commits When you select the Squash and merge option on a pull request, the pull request's commits are squashed into a single commit. Instead of seeing all of a contributor's individual commits from a topic branch, the commits are combined into one commit and merged into the default branch. Pull requests with squashed commits are merged using the fast-forward option. To squash and merge pull requests, you must have write permissions in the repository, and the repository must allow squash merging. You can use squash and merge to create a more streamlined Git history in your repository. Work-in-progress commits are helpful when working on a feature branch, but they aren’t necessarily important to retain in the Git history. If you squash these commits into one commit when merging to the default branch, the changes are consolidated, leading to a clear Git history. ## Merge message for a squash merge When you squash and merge, GitHub generates a default commit message, which you can edit. Depending on how the repository is configured and the number of commits in the pull request, not including merge commits, this message may include the pull request title, pull request description, or information about the commits. People with maintainer or admin access to a repository can configure their repository's default merge message for all squashed commits to use the pull request title, the pull request title and commit details, or the pull request title and description. For more information, see Configuring commit squashing for pull requests. ## Squashing and merging a long-running branch If you plan to continue work on the head branch of a pull request after the pull request is merged, we recommend you don't squash and merge the pull request. When you create a pull request, GitHub identifies the most recent commit that is on both the head branch and the base branch: the common ancestor commit. When you squash and merge the pull request, GitHub creates a commit on the base branch that contains all of the changes you made on the head branch since the common ancestor commit. Because this commit is only on the base branch and not the head branch, the common ancestor of the two branches remains unchanged. If you continue to work on the head branch, then create a new pull request between the two branches, the pull request will include all of the commits since the common ancestor, including commits that you squashed and merged in the previous pull request. If there are no conflicts, you can safely merge these commits. However, this workflow makes merge conflicts more likely. If you continue to squash and merge pull requests for a long-running head branch, you will have to resolve the same conflicts repeatedly. ## Rebase and merge your commits When you select the Rebase and merge option on a pull request, all commits from the topic branch (or head branch) are added onto the base branch individually without a merge commit. In that way, the rebase and merge behavior resembles a fast-forward merge by maintaining a linear project history. However, rebasing achieves this by re-writing the commit history on the base branch with new commits. The rebase and merge behavior on GitHub deviates slightly from git rebase. Rebase and merge on GitHub will always update the committer information and create new commit SHAs, whereas git rebase outside of GitHub does not change the committer information when the rebase happens on top of an ancestor commit. For more information about git rebase, see git-rebase in the Git documentation. To rebase and merge pull requests, you must have write permissions in the repository, and the repository must allow rebase merging. For a visual representation of git rebase, see The \"Git Branching - Rebasing\" chapter from the Pro Git book. You aren't able to automatically rebase and merge when: The pull request has merge conflicts. Rebasing the commits from the base branch into the head branch runs into conflicts. Rebasing the commits is considered \"unsafe,\" such as when a rebase is possible without merge conflicts but would produce a different result than a merge would. If you still want to rebase the commits but can't rebase and merge automatically, you must: Rebase the topic branch (or head branch) onto the base branch locally on the command line Resolve any merge conflicts on the command line. Force-push the rebased commits to the pull request's topic branch (or remote head branch). Anyone with write permissions in the repository, can then merge the changes using the rebase and merge button. ## Indirect merges A pull request can be merged automatically if its head branch is directly or indirectly merged into the base branch externally. In other words, if the head branch's tip commit becomes reachable from the tip of the target branch. For example: Branch main is at commit C. Branch feature has been branched off of main and is currently at commit D. This branch has a pull request targeting main. Branch feature_2 is branched off of feature and is now at commit E. This branch also has a pull request targeting main. If pull request E --> main is merged first, pull request D --> main will be marked as merged automatically because all of the commits from feature are now reachable from main. Merging feature_2 into main and pushing main to the server from the command line will mark both pull requests as merged. Indirect merges can only occur either when the commits in the pull request's head branch are pushed directly to the repository's default branch, or when the commits in the pull request's head branch are present in another pull request and are merged into the repository's default branch using the Create a merge commit option. If a pull request containing commits present in another pull request's head branch is merged using the Squash and merge or Rebase and merge options, a new commit is created on the base branch and the other pull request will not be automatically merged. Pull requests that are merged indirectly are marked as merged even if branch protection rules have not been satisfied. ## Further reading About pull requests Addressing merge conflicts",
    "url": "https://docs.github.com/en/pull-requests/collaborating-with-pull-requests/incorporating-changes-from-a-pull-request/about-pull-request-merges",
    "section": "Pull Requests",
    "word_count": 1132
  },
  {
    "title": "Approving a pull request with required reviews",
    "content": "## Approving a pull request with required reviews If your repository requires reviews, pull requests must have a specific number of approving reviews from people with write or admin permissions in the repository before they can be merged. For more information about required reviews, see About protected branches. You can comment on a pull request, approve the changes, or request improvements before approving. For more information, see Reviewing proposed changes in a pull request. You can find a pull request where you or a team you're a member of is requested for review with the search qualifier review-requested:[USERNAME] or team-review-requested:[TEAMNAME]. For more information, see Searching issues and pull requests. review-requested:[USERNAME] team-review-requested:[TEAMNAME] If a pull request you approved has changed significantly, you can dismiss your review. The pull request will need a new review before it can be merged. For more information, see Dismissing a pull request review. Under your repository name, click Pull requests. Under your repository name, click Pull requests. In the list of pull requests, click the pull request you'd like to review. In the list of pull requests, click the pull request you'd like to review. On the pull request, click Files changed. On the pull request, click Files changed. Review the changes in the pull request, and optionally, comment on specific lines or files. For more information, see Reviewing proposed changes in a pull request. Review the changes in the pull request, and optionally, comment on specific lines or files. For more information, see Reviewing proposed changes in a pull request. Above the changed code, click Review changes. Above the changed code, click Review changes. Type a comment summarizing your feedback on the proposed changes. Type a comment summarizing your feedback on the proposed changes. Select Approve to approve merging the changes proposed in the pull request. Select Approve to approve merging the changes proposed in the pull request. Click Submit review. Click Submit review. The Request changes option is purely informational and will not prevent merging unless a ruleset or classic branch protection rule is configured with the \"require a pull request\" option. If configured and a collaborator with admin, owner, or write access to the repository submits a review requesting changes, the pull request cannot be merged until the same collaborator submits another review approving the changes in the pull request. Repository owners and administrators can merge a pull request even if it hasn't received an approving review, or if a reviewer who requested changes has left the organization or is unavailable. If both required reviews and stale review dismissal are enabled and a code-modifying commit is pushed to the branch of an approved pull request, the approval is dismissed. The pull request must be reviewed and approved again before it can be merged. When several open pull requests each have a head branch pointing to the same commit, you won’t be able to merge them if one or both have a pending or rejected review. If your repository requires approving reviews from people with write or admin permissions, the reviewers sidebar groups approvals by permission level. Approvals can appear in two sections: The top section mostly contains approvals from people with write or admin permissions that count toward merge requirements. Approvals by GitHub Copilot also appear in this section even though GitHub Copilot reviews do not count toward those requirements. The collapsible section (if present) shows approvals from reviewers whose reviews do not affect whether the pull request can be merged. The top section mostly contains approvals from people with write or admin permissions that count toward merge requirements. Approvals by GitHub Copilot also appear in this section even though GitHub Copilot reviews do not count toward those requirements. The collapsible section (if present) shows approvals from reviewers whose reviews do not affect whether the pull request can be merged. Pull request authors cannot approve their own pull requests. You will also not be able to approve a pull request that was raised by GitHub Copilot if it was you who assigned Copilot to the issue to which the pull request relates. ## Further reading Reviewing proposed changes in a pull request Commenting on a pull request",
    "url": "https://docs.github.com/en/pull-requests/collaborating-with-pull-requests/reviewing-changes-in-pull-requests/approving-a-pull-request-with-required-reviews",
    "section": "Pull Requests",
    "word_count": 694
  },
  {
    "title": "Getting started",
    "content": "## Getting started Learn about the GitHub flow and different ways to collaborate on and discuss your projects. ## About collaborative development models The way you use pull requests depends on the type of development model you use in your project. You can use the fork and pull model or the shared repository model. ## Helping others review your changes You can use pull requests to provide clear context for your changes and keep your team informed, improving collaboration and the quality of reviews. ## Managing and standardizing pull requests Use these steps to manage and standardize the pull requests that contributors create in your repository.",
    "url": "https://docs.github.com/en/pull-requests/collaborating-with-pull-requests/getting-started",
    "section": "Pull Requests",
    "word_count": 106
  },
  {
    "title": "Viewing a pull request review",
    "content": "## Viewing a pull request review You can view all of the comments made in a single pull request review. You can find a pull request where you or a team you're a member of is requested for review with the search qualifier review-requested:[USERNAME] or team-review-requested:[TEAMNAME]. For more information, see Searching issues and pull requests. review-requested:[USERNAME] team-review-requested:[TEAMNAME] When you view a full review, you'll see the same version of the pull request as the reviewer did at the time of the review. Under your repository name, click Pull requests. Under your repository name, click Pull requests. In the list of pull requests, click the pull request you'd like to review. In the list of pull requests, click the pull request you'd like to review. On the \"Conversation\" tab, scroll to the review you'd like to see, then click View changes. On the \"Conversation\" tab, scroll to the review you'd like to see, then click View changes. ## Further reading About pull request reviews Reviewing proposed changes in a pull request Triaging code scanning alerts in pull requests",
    "url": "https://docs.github.com/en/pull-requests/collaborating-with-pull-requests/reviewing-changes-in-pull-requests/viewing-a-pull-request-review",
    "section": "Pull Requests",
    "word_count": 177
  },
  {
    "title": "Merging a pull request",
    "content": "## Merging a pull request Merge a pull request into the upstream branch when work is completed. Anyone with push access to the repository can complete the merge. ## Tool navigation ## In this article ## About pull request merges In a pull request, you propose that changes you've made on a head branch should be merged into a base branch. By default, any pull request can be merged at any time, unless the head branch is in conflict with the base branch. However, there may be restrictions on when you can merge a pull request into a specific branch. For example, you may only be able to merge a pull request into the default branch if required status checks are passing. Repository administrators can add constraints like this to branches using branch protection rules. For more information, see About protected branches. As an alternative to branch protection rules, you can create rulesets. Rulesets have a few advantages over branch protection rules, such as statuses, and better discoverability without requiring admin access. You can also apply multiple rulesets at the same time. For more information, see About rulesets. You can configure a pull request to merge automatically when all merge requirements are met. For more information, see Automatically merging a pull request. If the pull request has merge conflicts, or if you'd like to test the changes before merging, you can check out the pull request locally and merge it using the command line. You can't merge a draft pull request. For more information about draft pull requests, see About pull requests. The repository may be configured so that the head branch for a pull request is automatically deleted when you merge a pull request. For more information, see Managing the automatic deletion of branches. If you delete a head branch after its pull request has been merged, GitHub checks for any open pull requests in the same repository that specify the deleted branch as their base branch. GitHub automatically updates any such pull requests, changing their base branch to the merged pull request's base branch. For more information, see About branches. Pull requests are merged using the --no-ff option, except for pull requests with squashed or rebased commits, which are merged using the fast-forward option. You can link a pull request to an issue to show that a fix is in progress and to automatically close the issue when someone merges the pull request. For more information, see Linking a pull request to an issue. If you decide you don't want the changes in a topic branch to be merged to the upstream branch, you can close the pull request without merging. ## Merging a pull request Under your repository name, click Pull requests. Under your repository name, click Pull requests. In the \"Pull Requests\" list, click the pull request you'd like to merge. In the \"Pull Requests\" list, click the pull request you'd like to merge. Scroll down to the bottom of the pull request. Depending on the merge options enabled for your repository, you can: Merge all of the commits into the base branch by clicking Merge pull request. If the Merge pull request option is not shown, click the merge dropdown menu and select Create a merge commit. Squash the commits into one commit by clicking the merge dropdown menu, selecting Squash and merge and then clicking Squash and merge. Rebase the commits individually onto the base branch by clicking the merge dropdown menu, selecting Rebase and merge and then clicking Rebase and merge. Note Rebase and merge will always update the committer information and create new commit SHAs. For more information, see About pull request merges. Scroll down to the bottom of the pull request. Depending on the merge options enabled for your repository, you can: Merge all of the commits into the base branch by clicking Merge pull request. If the Merge pull request option is not shown, click the merge dropdown menu and select Create a merge commit. Merge all of the commits into the base branch by clicking Merge pull request. If the Merge pull request option is not shown, click the merge dropdown menu and select Create a merge commit. Squash the commits into one commit by clicking the merge dropdown menu, selecting Squash and merge and then clicking Squash and merge. Squash the commits into one commit by clicking the merge dropdown menu, selecting Squash and merge and then clicking Squash and merge. Rebase the commits individually onto the base branch by clicking the merge dropdown menu, selecting Rebase and merge and then clicking Rebase and merge. Rebase the commits individually onto the base branch by clicking the merge dropdown menu, selecting Rebase and merge and then clicking Rebase and merge. Rebase and merge will always update the committer information and create new commit SHAs. For more information, see About pull request merges. If prompted, type a commit message, or accept the default message. For information about the default commit messages for squash merges, see About pull request merges. If prompted, type a commit message, or accept the default message. For information about the default commit messages for squash merges, see About pull request merges. If you have more than one email address associated with your account on GitHub, click the email address drop-down menu and select the email address to use as the Git author email address. Only verified email addresses appear in this drop-down menu. If you enabled email address privacy, then a no-reply will be the default commit author email address. For more information about the exact form the no-reply email address can take, see Setting your commit email address. Note The email selector is not available for rebase merges, which do not create a merge commit. For squash merges, the email selector is only shown if you are the pull request author and you have more than one email address associated with your account. If you have more than one email address associated with your account on GitHub, click the email address drop-down menu and select the email address to use as the Git author email address. Only verified email addresses appear in this drop-down menu. If you enabled email address privacy, then a no-reply will be the default commit author email address. For more information about the exact form the no-reply email address can take, see Setting your commit email address. The email selector is not available for rebase merges, which do not create a merge commit. For squash merges, the email selector is only shown if you are the pull request author and you have more than one email address associated with your account. Click Confirm merge, Confirm squash and merge, or Confirm rebase and merge. Click Confirm merge, Confirm squash and merge, or Confirm rebase and merge. Optionally, delete the branch. This keeps the list of branches in your repository tidy. Optionally, delete the branch. This keeps the list of branches in your repository tidy. To learn more about GitHub CLI, see About GitHub CLI. To merge a pull request, use the gh pr merge subcommand. Replace pull-request with the number, URL, or head branch of the pull request. gh pr merge pull-request gh pr merge PULL-REQUEST gh pr merge PULL-REQUEST Follow the interactive prompts to complete the merge. For more information about the merge methods that you can choose, see About pull request merges. Alternatively, you can use flags to skip the interactive prompts. For example, this command will squash the commits into a single commit with the commit message \"my squash commit\", merge the squashed commit into the base branch, and then delete the local and remote branch. gh pr merge 523 --squash --body \"my squash commit\" --delete-branch gh pr merge 523 --squash --body \"my squash commit\" --delete-branch ## Further reading Reverting a pull request Syncing your branch in GitHub Desktop using GitHub Desktop About pull request merges Addressing merge conflicts",
    "url": "https://docs.github.com/en/pull-requests/collaborating-with-pull-requests/incorporating-changes-from-a-pull-request/merging-a-pull-request",
    "section": "Pull Requests",
    "word_count": 1320
  }
]